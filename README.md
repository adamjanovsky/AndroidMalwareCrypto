# AndroidMalwareCrypto
The analysis of cryptography in Android malicious applications. All knowledge regarding this project shall reside in the readme file if not stated otherwise.

## Install 

The project is tested on python 3.6. It should suffice to clone, install requirements and run (you may want to get the Neptune.ml token, see [Neptune integration](#neptune-integration) below). 

*Note: At the moment, development version of the [pyjadx](https://github.com/romainthomas/pyjadx) package is used. You must install this version manually and delete it from the requirements.txt, as it's not in the pip repositories yet. We recommend to use [virtual environment](https://docs.python.org/3.6/tutorial/venv.html).*

To install, run

```
git clone https://github.com/adamjanovsky/AndroidMalwareCrypto.git &&
cd AndroidMalwareCrypto &&
pip3 install -r requirements.txt &&
python3 ./setup.py install
```

## Usage

```
androidcrypto <path_to_yaml_configuration_file> -t <optionally a base64 encoded Neptune.ml token>
```

See [list of keys and options](#configuration-file) in configuration file.

## How to work with datasets

Make sure that your dataset folder is of the form

```
.
+-- DatasetFolder
|     +-- meta.yml
|     +-- data
|          +-- whatever folder structure with apk files
```

You can create meta.yml with `n_samples` set to 0 and with `sha_256` set to None, they will be updated automatically.

### How to transform dataset into compressed lzma analysis objects

Call `androidcrypto <path_to_config_file>`, where config file is constructed from the sample shown in [.../decompile_datasets.yml](https://github.com/adamjanovsky/AndroidMalwareCrypto/blob/master/sample_configs/decompile_datasets.yml). They dataset will be stored in the output path

### How to load the compressed lzma analysis objects

Not resolved finally yet. Use the snippet below. If some object fails, it means that the serialization failed in the previous phase. Investigate then.

```python
import lzma
from androguard.misc import AnalyzeAPK
import os

in_path = '/path/to/lzma/objects'
    files = [os.path.join(in_path, x) for x in os.listdir(in_path)]
    analysis_files = []
    for f in files:
        with lzma.open(f, 'rb') as handle:
            try:
                analysis_files.append(pickle.load(handle))
            except Exception as e:
                print(e)
```


## Architecture

The main logical unit of the project is an `experiment`. Experiment does not have its own class, but is operated in three dimensions:

1) An `ExperimentConfig` class parses the input from yaml configuration file, see [config example](https://github.com/adamjanovsky/AndroidMalwareCrypto/blob/master/sample_configs/base64.yml).

2) An `ExperimentRunner` calls the task specified in `ExperimentConfig`.

3) A `Task` class does the heavy lifting. To be specific, it's an abstract class, parent class of various specific tasks that do the heavy lifting, e.g. `DeobfuscateBase64` task. These tasks inherit the global structure from the parent class. 

If correctly thought, this architecture should survive the whole development cycle and be maintained. At the moment, it is sort of possible to define multiple experiments within single configuration file, we could extend the source code to run them. 

## Neptune integration

The project is meant to be fully integrated with [Neptune.ml](Neptune.ml). This allows us to track all experiments perfmored with the project. The `Team/Project_name` is to be supplied from the config file, whereas the personal API token is supplied as a command-line parameter. 

## Configuration file

Below is a list and description of options inside the configuration file

- `tasks`: A list of tasks to perform. This actually defines what the tool will compute.
	- Supported tasks: `deobfuscate`, `word_statistics` 
- `is_being_logged`: True if Neptune.ml shall be active, False otherwise 
- `neptune_project_name`: Name of the corresponding Neptune.ml project, we use 'CRoCS/CryptoMalware'
- `experiment_name`: Name of the performed experiment
- `input_path`:  At the moment not used, path from where additional inputs beyond the datasets are loaded
- `dataset_paths`: List of paths to the datasets. Note that in each path, there must be a dataset file `meta.yml` present together with a subfolder `./data` containing the apks (or other subfolders)
- `output_path`: Path where the folder with experiment ID will be created, e.g. `CRYPTOM-26`. Inside that folder, artifacts of the experiment will be stored.


## License

MIT, but should be decided when we publish it... 

