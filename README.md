# AndroidMalwareCrypto
The analysis of cryptography in Android malicious applications. All knowledge regarding this project shall reside in the readme file if not stated otherwise.

## Install 

The project is tested on python 3.6. It should suffice to clone, install requirements and run (you may want to get the Neptune.ml token, see [Neptune integration](#neptune-integration) below). 

*Note: At the moment, development version of the [pyjadx](https://github.com/romainthomas/pyjadx) package is used. You must install this version manually and delete it from the requirements.txt, as it's not in the pip repositories yet. We recommend to use [virtual environment](https://docs.python.org/3.6/tutorial/venv.html).*

To install, run

```
git clone https://github.com/adamjanovsky/AndroidMalwareCrypto.git &&
cd AndroidMalwareCrypto &&
pip3 install -r requirements.txt &&
python3 ./setup.py install
```

## Usage

```
androidcrypto <path_to_yaml_configuration_file> -t <optionally a base64 encoded Neptune.ml token>
```

See [list of keys and options](#configuration-file) in configuration file.

## How to work with datasets

### Folder structure

```
.
+-- DatasetFolder
|     +-- meta.yml
|     +-- data
|          +-- whatever folder structure with apk or lzma files
```

You can create meta.yml with `n_samples: 0` and with `sha_256: None`, they will be updated automatically. For any analysis, we recommend to work with the [Analysis](https://androguard.readthedocs.io/en/latest/api/androguard.core.analysis.html) objects defined in Androguard package. 

### Format of dataset -- apk vs. lzma

Our tool provides a simple way of transforming apk dataset into the dataset of files, that are lzma compressed, pickle serialized Analysis objects. Too difficult to understand? See the list below. 

1. We start with the dataset of apks
2. We create Androguard `Analysis` objects out of them
3. We serialize the objects with `pickle` package
4. We save the pickle objects as lzma-compressed file.

It is very convenient to work with the analysis objects, as you can do all sorts of experiments with them. It is possible to access the Dataset object in both `apk` and `lzma` format. You will probably want to iterate over dataset in order to analyze the apks. You will always obtain the `Analysis` class when iterating (or `None` type when loading the apk fails). The difference is that when using dataset in `apk` format, you need to decompile it into the Analysis objects anytime you run an experiment. On the contrary, you can access the Analysis objects directly when working with the `lzma` format. Prior to running any serious experiments, we therefore recommend to Transform your datasets using the task [TransformDataset](https://github.com/adamjanovsky/AndroidMalwareCrypto/blob/master/androidcrypto/analyzer.py#L192) with the help of the [config file](https://github.com/adamjanovsky/AndroidMalwareCrypto/blob/master/sample_configs/decompile_datasets.yml). 

### Iterating over dataset

You can iterate over the dataset as follows

```python
from androidcrypto.dataset import Dataset

dset = Dataset('path/to/root/dir/with/your/dataset')
for sample in dset.generator():
    print(sample)
```

The evaluation shall be lazy, thus it should pose no problem to iterate over millions of apks.

## Architecture

The main logical unit of the project is an `experiment`. Experiment does not have its own class, but is operated in three dimensions:

1) An `ExperimentConfig` class parses the input from yaml configuration file, see [config example](https://github.com/adamjanovsky/AndroidMalwareCrypto/blob/master/sample_configs/base64.yml).

2) An `ExperimentRunner` calls the task specified in `ExperimentConfig`.

3) A `Task` class does the heavy lifting. To be specific, it's an abstract class, parent class of various specific tasks that do the heavy lifting, e.g. `DeobfuscateBase64` task. These tasks inherit the global structure from the parent class. 

If correctly thought, this architecture should survive the whole development cycle and be maintained. At the moment, it is sort of possible to define multiple experiments within single configuration file, we could extend the source code to run them. 

## Neptune integration

The project is meant to be fully integrated with [Neptune.ml](Neptune.ml). This allows us to track all experiments perfmored with the project. The `Team/Project_name` is to be supplied from the config file, whereas the personal API token is supplied as a command-line parameter. 

## Configuration file

Below is a list and description of options inside the configuration file

- `tasks`: A list of tasks to perform. This actually defines what the tool will compute.
	- Supported tasks: `deobfuscate`, `word_statistics` 
- `is_being_logged`: True if Neptune.ml shall be active, False otherwise 
- `neptune_project_name`: Name of the corresponding Neptune.ml project, we use 'CRoCS/CryptoMalware'
- `experiment_name`: Name of the performed experiment
- `input_path`:  At the moment not used, path from where additional inputs beyond the datasets are loaded
- `dataset_paths`: List of paths to the datasets. Note that in each path, there must be a dataset file `meta.yml` present together with a subfolder `./data` containing the apks (or other subfolders)
- `output_path`: Path where the folder with experiment ID will be created, e.g. `CRYPTOM-26`. Inside that folder, artifacts of the experiment will be stored.


## License

MIT, but should be decided when we publish it... 

