import os
from collections import OrderedDict
import yaml
import json
import tempfile
import shutil
import logging

from androidcrypto.sample import Sample
from androidcrypto import helpers, constants


class DatasetException(Exception):
    pass


class Dataset:
    def __init__(self, root_path):
        self.samples = {}

        self.root_path = root_path
        self.meta_path = os.path.join(self.root_path, constants.META_FILENAME)
        self.json_path = os.path.join(self.root_path, constants.JSON_FILENAME)
        self.processed_json_path = os.path.join(self.root_path, constants.PROCESSED_JSON_FILENAME)
        self.data_path = os.path.join(self.root_path, constants.DATA_DIRNAME)
        self.apk_path = os.path.join(self.data_path, constants.APK_DIRNAME)
        self.dx_path = os.path.join(self.data_path, constants.DX_DIRNAME)
        self.third_party_tmp_path = None

        self.apk_available = False
        self.dx_available = False

        self.sha_digest = 'Not yet implemented'

        self.name = None
        self.description = None

        self.n_processed_samples = 0
        self.processed_samples_codes = {x: 0 for x in constants.StatusCode}

        self.correctly_processed_samples_ids = set()

        self._init_dataset()

    def __iter__(self):
        for sample in self.samples.values():
            yield sample

    def __getitem__(self, item):
        return self.samples.__getitem__(item.lower())

    def __setitem__(self, key, value):
        self.samples.__setitem__(key.lower(), value)

    def __len__(self):
        return len(self.samples)

    def __str__(self):
        return f'Dataset: {self.name} with {len(self)} samples, apk_available={self.apk_available}, dx_available={self.dx_available}.'

    def _init_dataset(self):
        if os.path.isfile(self.meta_path) and os.path.isfile(self.json_path):
            self.init_from_json()
        else:
            self.init_from_apks()

        self._update_meta()
        logging.info('Correctly initialized the dataset.')

    def init_from_apks(self):
        if not os.path.exists(self.root_path):
            os.makedirs(self.root_path)

        self.name = 'Pick your dataset name here'
        self.description = 'Put your dataset description here'
        self.apk_available = False
        self.dx_available = False

        for root, dir, files in os.walk(self.apk_path):
            dir_apks = [os.path.join(root, f) for f in files if f.endswith('apk')]

            for apk_path in dir_apks:
                smpl = Sample.from_apk(apk_path)
                self[smpl.sha256] = smpl

    # TODO: We should sanitize if all samples are valid here
    def init_from_json(self):
        with open(self.meta_path, 'r') as meta_file:
            config = yaml.load(meta_file, Loader=yaml.FullLoader)
            self.name = config['dataset_name']
            self.description = config['description']
            self.apk_available = config['apk_available']
            self.dx_available = config['dx_available']
        with open(self.json_path, 'r') as json_file:
            data = json.load(json_file)

            for sha256, record in data.items():
                self[sha256] = Sample.from_dict(sha256, record)

    def _update_meta(self):
        with open(self.meta_path, 'w') as meta_file:
            config = {'dataset_name': self.name,
                      'description': self.description,
                      'n_samples': len(self),
                      'apk_available': self.apk_available,
                      'dx_available': self.dx_available}
            yaml.dump(config, meta_file)

    # TODO: Too slow and non-idiomatic. Fix me.
    def dump_to_json(self):
        data = {sample.sha256: sample.to_dict() for sample in self}
        with open(self.json_path, 'w') as handle:
            json.dump(data, handle, indent=2)

    def dump_processed_samples_to_json(self, final=False):
        data = {self[x].sha256: self[x].to_dict() for x in self.correctly_processed_samples_ids}
        if data:
            with open(self.processed_json_path, 'w') as handle:
                json.dump(data, handle, indent=2)

        if final is True:
            pass

    def serialize_dataset(self):
        self._clean_up_failed_samples()
        self._update_meta()
        self.dump_to_json()

        try:
            os.remove(self.processed_json_path)
        except OSError:
            pass

    def _clean_up_failed_samples(self):
        for sample in [x for x in self.samples.keys() if x not in self.correctly_processed_samples_ids]:
            del self.samples[sample]

    def prepare_apk_paths(self):
        os.makedirs(self.apk_path, exist_ok=True)
        for sample in self:
            sample.apk_path = os.path.join(self.apk_path, sample.sha256 + '.apk')

    def prepare_dx_paths(self):
        for sample in self:
            relative_directory = os.path.dirname(os.path.relpath(sample.apk_path, self.apk_path))
            dir_to_create = os.path.join(self.dx_path, relative_directory)
            os.makedirs(dir_to_create, exist_ok=True)
            sample.dx_path = os.path.join(dir_to_create, str(
                os.path.basename(sample.apk_path).split('.apk')[0]) + '.lzma')

    def prepare_third_party_lib_paths(self):
        self.third_party_tmp_path = tempfile.mkdtemp()
        for sample in self:
            sample.literadar_tmp_path = os.path.join(self.third_party_tmp_path, str(sample.sha256) + '.json')

    def prepare_download(self, download_config):
        samples_to_download = helpers.filter_androzoo_dataset(download_config.n_samples, download_config.csv_path,
                                                              download_config.start_year, download_config.end_year,
                                                              download_config.minimal_vt_positives,
                                                              download_config.max_size, download_config.strategy)
        for s in samples_to_download:
            download_url = helpers.get_androzoo_url(s['sha256'], download_config.api_token)
            dex_year = helpers.androzoo_parse_year(s['dex_date'])
            self[s['sha256']] = Sample(s['sha256'], download_url, dex_year)

        self.prepare_apk_paths()

    def delete_third_party_tmp_folder(self):
        shutil.rmtree(self.third_party_tmp_path)
