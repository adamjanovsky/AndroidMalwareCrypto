import os
import sys
import contextlib
from time import gmtime, strftime
from androguard.core.bytecodes.dvm import ClassDefItem
import io
from contextlib import redirect_stdout
import re
import hashlib
from androidcrypto import constants
import base64

def find_all_files_with_extension(dir_to_search, extension):
    all_files = [os.path.join(dp, f) for dp, dn, fn in os.walk(os.path.expanduser(dir_to_search)) for f in fn]
    return [f for f in all_files if f.endswith(extension)]


def get_apk_label(path):
    tokens = path.split('/')
    if len(tokens) > 2:
        return tokens[-2]
    else:
        return 'none'


def establish_results_filepath(dir_path, prefix, suffix):
    """
    Used to derive filepath in which the file can be stored if the filename already exists.
    Just keeps adding + symbols until a non-existing filepath is achieved
    :param dir_path: directory to search
    :param prefix: prefix of the desired file
    :param suffix: suffix of the desired file
    :return: The feasible path that can be used to store whatever needs to be stored.
    """
    while True:
        candidate = os.path.join(dir_path, prefix + '.' + suffix)
        if not os.path.exists(candidate):
            break
        prefix += '+'
    return candidate


@contextlib.contextmanager
def suppress_stdout(suppress=True):
    std_ref = sys.stdout
    if suppress:
        sys.stdout = open('/dev/null', 'w')
        yield
    sys.stdout = std_ref


def generate_experiment_results_filepath(desired_folder, filename, suffix):
    """
    Not being used at the moment
    """
    candidate_path = os.path.join(desired_folder, filename)

    while os.path.exists(candidate_path + suffix):
        os.path.join(candidate_path, '+')
        curr_time = strftime("_%Y%m%dt%H%M%S", gmtime())
        candidate_path += curr_time

    return candidate_path + suffix


def decolorize_source_code(src_code):
    reaesc = re.compile(r'\x1b[^m]*m')
    return reaesc.sub('', src_code)


def extract_class_source_code(class_analysis):
    """
    Will not work on JADX decompiled samples. For those, use class_analysis.get_vm_class().get_source() instead.
    """
    cls_vm = class_analysis.get_vm_class()
    if isinstance(cls_vm, ClassDefItem):
        f = io.StringIO()
        with redirect_stdout(f):
            cls_vm.source()
        source_code_colored = f.getvalue()
        return decolorize_source_code(source_code_colored)
    else:
        return None


def hash_file(path):
    hasher = hashlib.sha1()
    with open(path, 'rb') as afile:
        buf = afile.read(constants.BLOCKSIZE)
        while len(buf) > 0:
            hasher.update(buf)
            buf = afile.read(constants.BLOCKSIZE)
    return hasher.hexdigest()


def decode_base64_line_of_code(line_of_code):
    splt = line_of_code.split('Base64.decode("')
    if len(splt) > 1:
        return base64.decodebytes(str.encode(splt[1].split('\"')[0]))
    else:
        return None
