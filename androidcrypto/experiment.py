import functools
import logging
import os
import shutil
import sys
import json
from datetime import datetime, timedelta
from multiprocessing import Pool

import neptune
from stopit import SignalTimeout, TimeoutException

import androidcrypto.constants as constants
from androidcrypto.constants import StatusCode, EvaluateException, ThirdPartyException, DecompileException, \
    DownloadException, LabelException, ExperimentException

from androidcrypto.workers.decompile import decompile_worker
from androidcrypto.workers.download import download_worker
from androidcrypto.workers.evaluate import evaluate_worker
from androidcrypto.workers.third_party import third_party_worker

logger = logging.getLogger(__name__)


class Experiment:
    def __init__(self, experiment_config):
        self.cfg = experiment_config
        self.dset = self.cfg.dset

        self.experiment = None
        self.experiment_id = 'untitled'
        self.start_time = datetime.now()
        self.last_update_time = datetime.now()
        self.progress_metric_name = 'progress'

        download_cfg = self.cfg.tasks.get(constants.TaskName.DOWNLOAD, None)
        self.delete_apks = False
        if download_cfg is not None:
            self.delete_apks = download_cfg.delete_apks

        decompile_cfg = self.cfg.tasks.get(constants.TaskName.DECOMPILE, None)
        self.delete_dxs = False
        if decompile_cfg is not None:
            self.delete_dxs = decompile_cfg.delete_dxs

    def init_neptune(self):
        if self.cfg.is_being_logged:
            neptune.init(project_qualified_name=self.cfg.neptune_project_name, api_token=self.cfg.neptune_api_token)
            self.experiment = neptune.create_experiment(name=self.cfg.experiment_name)
            self.experiment.set_property(self.dset.name + ' version', self.dset.sha_digest)
            #self.experiment.append_tag(self.dset.name)

    def prepare_experiment(self):
        self.init_neptune()

        if constants.TaskName.DOWNLOAD in self.cfg.tasks.keys():
            if self.dset.apk_available is True:
                raise ExperimentException('Apks already available while trying to donwload others.')
            self.dset.prepare_download(self.cfg.tasks[constants.TaskName.DOWNLOAD])

        if constants.TaskName.DECOMPILE in self.cfg.tasks.keys():
            if self.dset.dx_available is True:
                raise ExperimentException(f'Error: dxs already available while trying to decompile. Exiting.')
            self.dset.prepare_dx_paths()

        if constants.TaskName.THIRD_PARTY_LIBS in self.cfg.tasks.keys():
            self.dset.prepare_third_party_lib_paths()

        self.log_progress(force_log=True)

    def run(self):
        logging.info('Initializing experiment.')
        try:
            self.prepare_experiment()
        except Exception as e:
            logging.error(f'Failed to initialize the experiment: {e}')
        else:
            process_pool = Pool(self.cfg.n_threads)
            partial_worker = functools.partial(self.super_worker, tasks=self.cfg.tasks, timeout=self.cfg.timeout)
            logging.info(f'Established process pool with {self.cfg.n_threads} subprocesses. Starting processing {len(self.dset)} samples.')

            for sample in self.dset:
                process_pool.apply_async(partial_worker, (sample, ), callback=self.super_worker_callback)

            process_pool.close()
            process_pool.join()

            logging.info(f'Successfully processed {self.dset.processed_samples_codes[StatusCode.OK]} out of {len(self.dset)} samples.')
            logging.info(f'Cleaning up after experiment.')

            try:
                self.finalize_experiment()
            except Exception as e:
                logging.error(f'Failed to finalize the experiment: {e}')

    def finalize_experiment(self):
        for status_code in StatusCode:
            logging.info(f'Number of samples with exit code {status_code.value}: {self.dset.processed_samples_codes[status_code]}.')

        if self.delete_apks is True and os.path.exists(self.dset.apk_path):
            shutil.rmtree(self.dset.apk_path)

        if self.delete_dxs is True and os.path.exists(self.dset.dx_path):
            shutil.rmtree(self.dset.dx_path)

        if self.delete_apks is False and (self.dset.apk_available is True or constants.TaskName.DOWNLOAD in self.cfg.tasks.keys()):
            self.dset.apk_available = True
        if self.delete_dxs is False and (self.dset.dx_available is True or constants.TaskName.DECOMPILE in self.cfg.tasks.keys()):
            self.dset.dx_available = True

        if constants.TaskName.THIRD_PARTY_LIBS in self.cfg.tasks.keys():
            self.dset.delete_third_party_tmp_folder()

        if constants.TaskName.LABEL in self.cfg.tasks.keys():
            self.label_samples()

        self.log_progress(force_log=True)
        self.dset.serialize_dataset()
        self.eval_neptune()
        self.delete_literadar_log()

    @staticmethod
    def super_worker(sample, tasks, timeout=constants.TIMEOUT_CONSTANT):
        logging.debug(f'Starting super worker on {sample}')
        status_code = StatusCode.OK
        curr_time = datetime.now()

        with SignalTimeout(timeout):
            try:
                if constants.TaskName.DOWNLOAD in tasks.keys():
                    download_worker(sample, tasks[constants.TaskName.DOWNLOAD])
                if constants.TaskName.DECOMPILE in tasks.keys():
                    decompile_worker(sample, tasks[constants.TaskName.DECOMPILE])
                if constants.TaskName.THIRD_PARTY_LIBS in tasks.keys():
                    third_party_worker(sample, tasks[constants.TaskName.THIRD_PARTY_LIBS])
                if constants.TaskName.EVALUATE in tasks.keys():
                    evaluate_worker(sample, tasks[constants.TaskName.EVALUATE])

            except TimeoutException:
                logging.warning(f'Timeout on {sample} after {datetime.now() - curr_time} seconds.')
                status_code = StatusCode.FAILED_TIMEOUT
            except DownloadException:
                status_code = StatusCode.FAILED_ON_DOWNLOAD
            except DecompileException:
                status_code = StatusCode.FAILED_ON_DECOMPILE
            except ThirdPartyException:
                status_code = StatusCode.FAILED_ON_THIRD_PARTY
            except EvaluateException:
                status_code = StatusCode.FAILED_ON_EVALUATE
            except Exception as e:
                logging.error(f'Failed on unknown exception: {e}')
                status_code = StatusCode.FAILED_UNKNOWN

            return status_code, sample

    def super_worker_callback(self, result):
        status_code, sample = result
        self.dset[sample.sha256] = sample

        if constants.TaskName.DOWNLOAD in self.cfg.tasks.keys():
            sample.androzoo_url = None

        delete_apk = self.delete_apks
        delete_dx = self.delete_dxs
        delete_literadar_tmp = constants.TaskName.THIRD_PARTY_LIBS in self.cfg.tasks.keys()

        if status_code == StatusCode.OK:
            self.dset.correctly_processed_samples_ids.add(sample.sha256)
        else:
            delete_dx = True
            delete_apk = self.cfg.delete_corrupted

        sample.delete_auxillary_files(delete_apk, delete_dx, delete_literadar_tmp)

        logging.debug(f'Finished on {sample} with {status_code}.')

        self.dset.n_processed_samples += 1
        self.dset.processed_samples_codes[status_code] += 1

        if not self.dset.n_processed_samples % constants.JSON_CHUNK_SIZE:
            self.dset.dump_processed_samples_to_json()
        self.log_progress()

    def label_samples(self):
        try:
            with open(self.cfg.tasks[constants.TaskName.LABEL].euphony_names_path, 'r') as json_handle:
                euphony_names = json.load(json_handle)
        except OSError:
            logging.error('Euphony names file not found.')
            raise LabelException('Euphony names file not found.')

        try:
            with open(self.cfg.tasks[constants.TaskName.LABEL].euphony_types_path, 'r') as json_handle:
                euphony_types = json.load(json_handle)
        except OSError:
            logging.error('Euphony types file not found.')
            raise LabelException('Euphony types file not found.')

        for sample in self.dset:
            sample.euphony_name = euphony_names.get(sample.sha256, None)
            sample.euphony_type = euphony_types.get(sample.sha256, None)

    def log_progress(self, force_log=False):
        if self.cfg.is_being_logged is True and (datetime.now() - self.last_update_time > timedelta(seconds=50) or force_log is True):
            self.last_update_time = datetime.now()
            fraction = self.dset.n_processed_samples / len(self.dset)
            try:
                self.experiment.log_metric(self.progress_metric_name, (self.last_update_time - self.start_time).total_seconds(), y=fraction)
                self.log_processed_samples()
            except Exception as e:
                logging.error(f'Error when reporting progress to neptune: {e}')

    def log_processed_samples(self):
        for status_code in StatusCode:
            self.experiment.log_metric(status_code.value, self.dset.processed_samples_codes[status_code])

    def eval_neptune(self):
        if self.cfg.is_being_logged:
            n_failed_samples = 0
            for key, val in self.dset.processed_samples_codes.items():
                if key != StatusCode.OK:
                    n_failed_samples += val
            try:
                neptune.log_artifact(self.cfg.config_path)
                neptune.log_artifact(constants.LOGS_FILENAME)
                neptune.log_metric('Total_n_failed_samples', n_failed_samples)
                neptune.stop()
            except Exception as e:
                logging.error(f'Error when evaluating neptune experiment: {e}')

    @staticmethod
    def delete_literadar_log():
        try:
            os.remove('./log_libradar.txt')
        except OSError:
            logging.warning('Libradar log was not found thus was not deleted.')