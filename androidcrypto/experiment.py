import os
import neptune
import sys
import shutil

from datetime import datetime, timedelta
from copy import deepcopy
from multiprocessing import Pool
from stopit import ThreadingTimeout, TimeoutException

import androidcrypto.constants as constants

from androidcrypto.workers.decompile import decompile_worker
from androidcrypto.workers.download import download_worker
from androidcrypto.workers.third_party import third_party_worker
from androidcrypto.workers.evaluate import evaluate_worker
from androidcrypto.helpers import DownloadException, DecompileException, ThirdPartyException, EvaluateException
from androidcrypto.helpers import StatusCode


class Experiment:
    def __init__(self, experiment_config):
        self.cfg = experiment_config
        self.dset = self.cfg.dset
        self.experiment = None
        self.experiment_id = 'untitled'
        self.start_time = datetime.now()
        self.last_update_time = datetime.now()
        self.progress_metric_name = 'progress'
        self.tasks = self.cfg.tasks

        download_cfg = self.cfg.tasks.get(constants.TASK_DOWNLOAD, None)
        self.delete_apks = False
        if download_cfg is not None:
            self.delete_apks = download_cfg.delete_apks

        decompile_cfg = self.cfg.tasks.get(constants.TASK_DECOMPILE, None)
        self.delete_dxs = False
        if decompile_cfg is not None:
            self.delete_dxs = decompile_cfg.delete_dxs

    def init_neptune(self):
        if self.cfg.is_being_logged:
            try:
                neptune.init(project_qualified_name=self.cfg.neptune_project_name,
                             api_token=self.cfg.neptune_api_token)
                self.experiment = neptune.create_experiment(name=self.cfg.experiment_name)

                self.experiment.set_property(self.dset.name + ' version', self.dset.sha_digest)
            except Exception as e:
                print(f'Error initiating Neptune: {e}')
            #self.experiment.append_tag(self.dset.name)

            self.cfg.experiment_id = str(self.experiment.id)

    def prepare_experiment(self):
        self.init_neptune()

        if constants.TASK_DOWNLOAD in self.tasks.keys():
            if self.dset.apk_available is True:
                print(f'Error: apks already available while trying to download others...')
                sys.exit()
            self.dset.prepare_download(self.cfg.tasks[constants.TASK_DOWNLOAD])

        if constants.TASK_DECOMPILE in self.tasks.keys():
            if self.dset.dx_available is True:
                print(f'Error: dxs already available while trying to decompile...')
                sys.exit()
            self.dset.prepare_dx_paths()

        if constants.TASK_THIRD_PARTY_LIBS in self.tasks.keys():
            self.dset.prepare_third_party_lib_paths()

        self.log_progress(force_log=True)

    def run(self):
        self.prepare_experiment()

        process_pool = Pool(self.cfg.n_threads)

        for sample_id, sample_record in self.dset.generator_json():
            process_pool.apply_async(self.super_worker, (sample_id, sample_record, deepcopy(self.tasks), deepcopy(self.cfg.timeout)), callback=self.super_worker_callback)

        process_pool.close()
        process_pool.join()

        self.finalize_experiment()

    def finalize_experiment(self):
        if self.delete_apks is True and os.path.exists(self.dset.apk_path):
            shutil.rmtree(self.dset.apk_path)

        if self.delete_dxs is True and os.path.exists(self.dset.dx_path):
            shutil.rmtree(self.dset.dx_path)

        if self.delete_apks is False and (self.dset.apk_available is True or constants.TASK_DOWNLOAD in self.tasks.keys()):
            self.dset.apk_available = True
        if self.delete_dxs is False and (self.dset.dx_available is True or constants.TASK_DECOMPILE in self.tasks.keys()):
            self.dset.dx_available = True

        if constants.TASK_THIRD_PARTY_LIBS in self.tasks.keys():
            self.dset.delete_third_party_tmp_folder()

        self.log_progress(force_log=True)
        self.dset.clean_up_dataset()
        self.eval_neptune()

    @staticmethod
    def super_worker(sample_id, sample_record, tasks, timeout=constants.TIMEOUT_CONSTANT):
        status_code = StatusCode.OK

        with ThreadingTimeout(timeout):
            try:
                if constants.TASK_DOWNLOAD in tasks.keys():
                    androzoo_path = sample_record['metadata']['androzoo_url']
                    apk_path = sample_record['metadata']['apk_path']
                    download_worker(androzoo_path, apk_path)
                    sample_record['metadata']['androzoo_url'] = None
                if constants.TASK_DECOMPILE in tasks.keys():
                    apk_path = sample_record['metadata']['apk_path']
                    dx_path = sample_record['metadata']['dx_path']
                    decompile_worker(apk_path, dx_path, tasks[constants.TASK_DECOMPILE].jadx_path)
                if constants.TASK_THIRD_PARTY_LIBS in tasks.keys():
                    third_party_worker(sample_record, tasks[constants.TASK_THIRD_PARTY_LIBS].literadar_path)
                if constants.TASK_EVALUATE in tasks.keys():
                    evaluate_worker(sample_record, tasks[constants.TASK_EVALUATE].keywords)
            except TimeoutException:
                status_code = StatusCode.FAILED_TIMEOUT
            except DownloadException:
                status_code = StatusCode.FAILED_ON_DOWNLOAD
            except DecompileException:
                status_code = StatusCode.FAILED_ON_DECOMPILE
            except ThirdPartyException:
                status_code = StatusCode.FAILED_ON_THIRD_PARTY
            except EvaluateException:
                status_code = StatusCode.FAILED_ON_EVALUATE
            except Exception:
                status_code = StatusCode.FAILED_UNKNOWN

            return status_code, sample_id, sample_record

    def super_worker_callback(self, result):
        status_code, sample_id, sample_record = result

        if self.delete_apks is True:
            self.dset.delete_apk(sample_id)
            sample_record['metadata']['apk_path'] = None

        if self.delete_dxs is True:
            self.dset.delete_dx(sample_id)
            sample_record['metadata']['dx_path'] = None

        if constants.TASK_THIRD_PARTY_LIBS in self.tasks.keys():
            self.dset.delete_third_party_tmp_file(sample_id)
            del sample_record['metadata']['third_party_tmp_path']

        if status_code == StatusCode.OK:
            self.dset.processed_json_data[sample_id] = sample_record
        else:
            self.dset.clean_up_record(sample_id)

        self.dset.n_processed_samples += 1
        self.dset.processed_samples_codes[status_code] += 1

        # TODO: Only once in a while
        if not self.dset.n_processed_samples % constants.JSON_CHUNK_SIZE:
            self.dset.update_processed_data()
        self.log_progress()

    def log_progress(self, force_log=False):
        if (self.cfg.is_being_logged is True and (datetime.now() - self.last_update_time) > timedelta(seconds=50)) or force_log is True:
            self.last_update_time = datetime.now()
            fraction = self.dset.n_processed_samples / self.dset.n_samples
            try:
                self.experiment.log_metric(self.progress_metric_name, (self.last_update_time - self.start_time).total_seconds(), y=fraction)
                self.log_processed_samples()
            except Exception as e:
                print(f'Error when updating to neptune: {e}')

    def log_processed_samples(self):
        for status_code in StatusCode:
            self.experiment.log_metric(status_code.value, self.dset.processed_samples_codes[status_code])

    def eval_neptune(self):
        if self.cfg.is_being_logged:

            n_failed_samples = 0
            for key, val in self.dset.processed_samples_codes.items():
                if key != StatusCode.OK:
                    n_failed_samples += val

            try:
                neptune.send_artifact(self.cfg.config_path)
                neptune.log_metric('Total_n_failed_samples', n_failed_samples)
                neptune.stop()
            except Exception as e:
                print(f'Error when evaluating Neptune: {e}')
