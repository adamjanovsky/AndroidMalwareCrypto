import os
import androidcrypto.constants as constants

import logging
import neptune
from datetime import datetime, timedelta
from multiprocessing import Pool
from tqdm import tqdm
import sys


from androidcrypto.workers.decompile import decompile_worker
from androidcrypto.workers.download import download_worker
from androidcrypto.workers.third_party import third_party_worker
from androidcrypto.workers.evaluate import evaluate_worker


class Experiment:
    def __init__(self, experiment_config):
        self.cfg = experiment_config
        self.dset = self.cfg.dset
        self.experiment = None
        self.experiment_id = 'untitled'
        self.processed_samples = 0
        self.start_time = datetime.now()
        self.last_update_time = datetime.now()
        self.pbar = None
        self.progress_metric_name = 'progress'
        self.process_pool = None
        self.tasks = self.cfg.tasks

        self.failed_samples = []
        self.custom_jadx_path = 'jadx'  # TODO: Resolve this

        self.current_task = None
        self.pbar = None

        download_cfg = self.cfg.tasks.get(constants.TASK_DOWNLOAD, None)
        self.delete_apks = False
        if download_cfg is not None:
            self.delete_apks = download_cfg.delete_apks

        decompile_cfg = self.cfg.tasks.get(constants.TASK_DECOMPILE, None)
        self.delete_dxs = False
        if decompile_cfg is not None:
            self.delete_dxs = decompile_cfg.delete_dxs

    def init_neptune(self):
        if self.cfg.is_being_logged:
            neptune.init(project_qualified_name=self.cfg.neptune_project_name,
                         api_token=self.cfg.neptune_api_token)
            self.experiment = neptune.create_experiment(name=self.cfg.experiment_name)

            self.experiment.set_property(self.dset.name + ' version', self.dset.sha_digest)
            self.experiment.append_tag(self.dset.name)

            self.cfg.experiment_id = str(self.experiment.id)

    def prepare_experiment(self):
        if constants.TASK_DOWNLOAD in self.tasks.keys():
            self.dset.prepare_download(self.cfg.tasks[constants.TASK_DOWNLOAD])
            self.dset.prepare_apk_paths()

            if self.dset.apk_available is True:
                print(f'Error: apks already available while trying to download others...')
                sys.exit()

        if constants.TASK_DECOMPILE in self.tasks.keys():
            self.dset.prepare_dx_paths()

            if self.dset.dx_available is True:
                print(f'Error: dxs already available while trying to decompile...')
                sys.exit()

        if constants.TASK_THIRD_PARTY_LIBS in self.tasks.keys():
            self.dset.prepare_third_party_lib_paths()

    def run(self):
        self.init_neptune()
        self.prepare_experiment()

        process_pool = Pool(self.cfg.n_threads)
        with tqdm(total=self.dset.n_samples) as self.pbar:
            for sample_id, sample_record in self.dset.generator_json():
                #result = self.super_worker(sample_id, sample_record, self.tasks)
                #self.super_worker_callback(result)
                process_pool.apply_async(self.super_worker, (sample_id, sample_record, self.tasks), callback=self.super_worker_callback)
        process_pool.close()
        process_pool.join()

        for sample_id in self.failed_samples:
            self.dset.delete_record(sample_id)

        if self.delete_apks is True and os.path.exists(self.dset.apk_path):
            os.rmdir(self.dset.apk_path)

        if self.delete_dxs is True and os.path.exists(self.dset.dx_path):
            os.rmdir(self.dset.dx_path)

        if self.delete_apks is False and (self.dset.apk_available is True or constants.TASK_DOWNLOAD in self.tasks.keys()):
            self.dset.apk_available = True
        if self.delete_dxs is False and (self.dset.dx_available is True or constants.TASK_DECOMPILE in self.tasks.keys()):
            self.dset.dx_available = True

        if constants.TASK_THIRD_PARTY_LIBS in self.tasks.keys():
            self.dset.delete_third_party_tmp()

        self.dset.n_samples -= len(self.failed_samples)
        self.dset.update_meta()

        self.eval_neptune()

    @staticmethod
    def super_worker(sample_id, sample_record, tasks):
        success = True

        if constants.TASK_DOWNLOAD in tasks.keys():
            androzoo_path = sample_record['metadata']['androzoo_url']
            apk_path = sample_record['metadata']['apk_path']
            success = download_worker(androzoo_path, apk_path)
            sample_record['metadata']['androzoo_url'] = None

        if success is False:
            logging.info('Failed on downloading: %s', sample_id)
        else:
            logging.info('Successfully downloaded: %s', sample_id)

        if success is True and constants.TASK_DECOMPILE in tasks.keys():
            apk_path = sample_record['metadata']['apk_path']
            dx_path = sample_record['metadata']['dx_path']
            success = decompile_worker(apk_path, dx_path, tasks[constants.TASK_DECOMPILE].jadx_path)

        if success is False:
            logging.info('Failed on decompiling: %s', sample_id)
        else:
            logging.info('Successfully decompiled: %s', sample_id)

        if success is True and constants.TASK_THIRD_PARTY_LIBS in tasks.keys():
            success = third_party_worker(sample_record, tasks[constants.TASK_THIRD_PARTY_LIBS].literadar_path)

        if success is True and constants.TASK_EVALUATE in tasks.keys():
            success = evaluate_worker(sample_record, tasks[constants.TASK_EVALUATE].keywords)

        return success, sample_id, sample_record

    def super_worker_callback(self, result):
        self.pbar.update(1)

        success = result[0]
        sample_id = result[1]
        sample_record = result[2]

        if constants.TASK_THIRD_PARTY_LIBS in self.tasks.keys():
            del sample_record['metadata']['third_party_tmp_path']

        if success is True:
            if self.delete_apks is True:
                self.dset.delete_apk(sample_id)
                sample_record['metadata']['apk_path'] = None

            if self.delete_dxs is True:
                self.dset.delete_dx(sample_id)
                sample_record['metadata']['dx_path'] = None

            self.dset.update_record(sample_id, sample_record)
        else:
            self.failed_samples.append(sample_id)

        self.processed_samples += 1

        if self.cfg.is_being_logged is True and (datetime.now() - self.last_update_time) > timedelta(seconds=20):
            self.update_neptune_progress()
            self.last_update_time = datetime.now()

    def update_neptune_progress(self):
        if self.cfg.is_being_logged is True:
            curr_time = datetime.now()
            fraction = self.processed_samples / self.dset.n_samples
            self.experiment.log_metric(self.progress_metric_name, (curr_time - self.start_time).total_seconds(), y=fraction)

    def eval_neptune(self):
        if self.cfg.is_being_logged:
            neptune.send_artifact(self.cfg.config_path)
            neptune.stop()
