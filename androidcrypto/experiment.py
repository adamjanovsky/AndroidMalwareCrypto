import os
import androidcrypto.constants as constants
import logging
import neptune
from datetime import datetime, timedelta
import sys
from copy import deepcopy
from functools import partial
import shutil

from pebble import ProcessPool, ProcessExpired
from concurrent.futures import TimeoutError

from androidcrypto.workers.decompile import decompile_worker
from androidcrypto.workers.download import download_worker
from androidcrypto.workers.third_party import third_party_worker
from androidcrypto.workers.evaluate import evaluate_worker


class Experiment:
    def __init__(self, experiment_config):
        self.cfg = experiment_config
        self.dset = self.cfg.dset
        self.experiment = None
        self.experiment_id = 'untitled'
        self.start_time = datetime.now()
        self.last_update_time = datetime.now()
        self.pbar = None
        self.progress_metric_name = 'progress'
        self.process_pool = None
        self.tasks = self.cfg.tasks

        self.custom_jadx_path = 'jadx'  # TODO: Resolve this

        self.current_task = None
        self.pbar = None

        download_cfg = self.cfg.tasks.get(constants.TASK_DOWNLOAD, None)
        self.delete_apks = False
        if download_cfg is not None:
            self.delete_apks = download_cfg.delete_apks

        decompile_cfg = self.cfg.tasks.get(constants.TASK_DECOMPILE, None)
        self.delete_dxs = False
        if decompile_cfg is not None:
            self.delete_dxs = decompile_cfg.delete_dxs

    def init_neptune(self):
        if self.cfg.is_being_logged:
            try:
                neptune.init(project_qualified_name=self.cfg.neptune_project_name,
                             api_token=self.cfg.neptune_api_token)
                self.experiment = neptune.create_experiment(name=self.cfg.experiment_name)

                self.experiment.set_property(self.dset.name + ' version', self.dset.sha_digest)
            except:
                print('Error initiating Neptune.')
            #self.experiment.append_tag(self.dset.name)

            self.cfg.experiment_id = str(self.experiment.id)

    def prepare_experiment(self):
        self.init_neptune()

        if constants.TASK_DOWNLOAD in self.tasks.keys():
            if self.dset.apk_available is True:
                print(f'Error: apks already available while trying to download others...')
                sys.exit()
            self.dset.prepare_download(self.cfg.tasks[constants.TASK_DOWNLOAD])

        if constants.TASK_DECOMPILE in self.tasks.keys():
            if self.dset.dx_available is True:
                print(f'Error: dxs already available while trying to decompile...')
                sys.exit()
            self.dset.prepare_dx_paths()

        if constants.TASK_THIRD_PARTY_LIBS in self.tasks.keys():
            self.dset.prepare_third_party_lib_paths()

    def run(self):
        self.prepare_experiment()

        with ProcessPool(max_workers=self.cfg.n_threads) as pool:
            future = pool.map(partial(self.super_worker, tasks=deepcopy(self.tasks)), self.dset.generator_json(), timeout=300)
            iterator = future.result()

            index = 0
            while True:
                try:
                    index += 1
                    success, sample_id, sample_record = next(iterator)
                    self.super_worker_callback(success, sample_id, sample_record)
                except StopIteration:
                    break
                except TimeoutError:
                    sample_id = self.dset.sample_ids[index - 1]
                    print(f'Timed-out on sample {sample_id}')
                    self.super_worker_callback(False, sample_id, self.dset.json_data[sample_id])
                except ProcessExpired as error:
                    print(f'{error}: {error.exitcode}')
                    sample_id = self.dset.sample_ids[index - 1]
                    print(f'Timed-out on sample {sample_id}')
                    self.super_worker_callback(False, sample_id, self.dset.json_data[sample_id])
                except Exception as error:
                    print(f"function raised {error}")
                    sample_id = self.dset.sample_ids[index - 1]
                    print(f'Timed-out on sample {sample_id}')
                    self.super_worker_callback(False, sample_id, self.dset.json_data[sample_id])

        self.finalize_experiment()

    def finalize_experiment(self):
        if self.delete_apks is True and os.path.exists(self.dset.apk_path):
            shutil.rmtree(self.dset.apk_path)

        if self.delete_dxs is True and os.path.exists(self.dset.dx_path):
            shutil.rmtree(self.dset.dx_path)

        if self.delete_apks is False and (self.dset.apk_available is True or constants.TASK_DOWNLOAD in self.tasks.keys()):
            self.dset.apk_available = True
        if self.delete_dxs is False and (self.dset.dx_available is True or constants.TASK_DECOMPILE in self.tasks.keys()):
            self.dset.dx_available = True

        if constants.TASK_THIRD_PARTY_LIBS in self.tasks.keys():
            self.dset.delete_third_party_tmp_folder()

        self.dset.clean_up_dataset()
        self.eval_neptune()

    @staticmethod
    def super_worker(sample, tasks):
        sample_id = sample[0]
        sample_record = sample[1]
        success = True

        if constants.TASK_DOWNLOAD in tasks.keys():
            androzoo_path = sample_record['metadata']['androzoo_url']
            apk_path = sample_record['metadata']['apk_path']
            success = download_worker(androzoo_path, apk_path)
            sample_record['metadata']['androzoo_url'] = None

        if success is True and constants.TASK_DECOMPILE in tasks.keys():
            print(f'Beginning with decompilation of: {sample_id}')
            apk_path = sample_record['metadata']['apk_path']
            dx_path = sample_record['metadata']['dx_path']
            success = decompile_worker(apk_path, dx_path, tasks[constants.TASK_DECOMPILE].jadx_path)

        if success is True and constants.TASK_THIRD_PARTY_LIBS in tasks.keys():
            print(f'Beginning with third party analysis of: {sample_id}')
            success = third_party_worker(sample_record, tasks[constants.TASK_THIRD_PARTY_LIBS].literadar_path)

        if success is True and constants.TASK_EVALUATE in tasks.keys():
            success = evaluate_worker(sample_record, tasks[constants.TASK_EVALUATE].keywords)

        return success, sample_id, sample_record

    def super_worker_callback(self, success, sample_id, sample_record):
        if not success:
            print(f'Failed on {sample_id}')
        else:
            print(f'Success on {sample_id}')

        if self.delete_apks is True:
            self.dset.delete_apk(sample_id)
            sample_record['metadata']['apk_path'] = None

        if self.delete_dxs is True:
            self.dset.delete_dx(sample_id)
            sample_record['metadata']['dx_path'] = None

        if constants.TASK_THIRD_PARTY_LIBS in self.tasks.keys():
            self.dset.delete_third_party_tmp_file(sample_id)
            del sample_record['metadata']['third_party_tmp_path']

        if success is True:
            self.dset.processed_json_data[sample_id] = sample_record
        else:
            self.dset.n_failed_samples += 1
            self.dset.clean_up_record(sample_id)

        self.dset.n_processed_samples += 1

        # TODO: Only once in a while
        if not self.dset.n_processed_samples % 1000:
            self.dset.update_processed_data()
        self.log_progress()

    def log_progress(self):
        if self.cfg.is_being_logged is True and (datetime.now() - self.last_update_time) > timedelta(seconds=50):
            self.last_update_time = datetime.now()
            fraction = self.dset.n_processed_samples / self.dset.n_samples
            try:
                self.experiment.log_metric(self.progress_metric_name, (self.last_update_time - self.start_time).total_seconds(), y=fraction)
            except:
                print('Error when updating to neptune.')

    def eval_neptune(self):
        if self.cfg.is_being_logged:
            try:
                neptune.send_artifact(self.cfg.config_path)
                neptune.stop()
            except:
                print('Error when evaluating Neptune.')
