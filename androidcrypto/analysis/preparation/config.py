"""Contains classes and functions for parsing config for preparation.

Author: Dominik Macko
"""

from dataclasses import InitVar, dataclass, field
from typing import List, Dict, Any, Optional
import yaml

@dataclass(frozen=True)
class CleaningLabelsConfig:

    name_rules: Dict[str, str] = field(init=False, default_factory=lambda: dict())
    type_rules: Dict[str, str] = field(init=False, default_factory=lambda: dict())
    names_to_ignore_during_mapping: List[str] = field(init=False, default_factory=lambda: ["UNKNOWN", "BENIGN"])

    config: InitVar[Dict[str, Any]]

    def __post_init__(self, config: Dict[str, Any]):
        for k, v in config.items():
            super().__setattr__(k, v)

@dataclass(frozen=True)
class CleaningCryptoAPIConfig:
    remove_when_imports_empty: bool = field(init=False, default=True)
    remove_duplicates: bool = field(init=False, default=True)
    remove_false_positives: bool = field(init=False, default=True)
    calls_to_filter: List[str] = field( # does not get triggered when remove_false_positives is False
        init=False,
        default_factory=lambda: ["Cipher", "PRIVATE_KEY", "SECRET_KEY", "PUBLIC_KEY", "ENCRYPT_MODE"])

    config: InitVar[Dict[str, Any]]

    def __post_init__(self, config: Dict[str, Any]):
        for k, v in config.items():
            super().__setattr__(k, v)

@dataclass(frozen=True)
class CleaningInputPath:
    path: str = field(init=False)
    benign: bool = field(init=False)
    source: str = field(init=False, default="Unknown")

    config: InitVar[Dict[str, Any]]
    
    def __post_init__(self, config: Dict[str, Any]):
        for k, v in config.items():
            super().__setattr__(k, v)

@dataclass(frozen=True)
class CleaningConfig:
    input_json_paths: List[CleaningInputPath] = field(init=False, default_factory=lambda: [])
    output_json_path: Optional[str] = field(init=False, default=None)
    labels_config: Optional[CleaningLabelsConfig] = field(init=False, default=None)
    remove_third_party_crypto_from_packages: bool = field(init=False, default=True)
    remove_similar_records_classes: bool = field(init=False, default=True)
    crypto_api_calls_config: Optional[CleaningCryptoAPIConfig] = field(init=False, default=None)

    config: InitVar[Dict[str, Any]]

    def __post_init__(self, config: Dict[str, Any]):
        for k, v in config.items():
            if k == "labels":
                super().__setattr__(f"{k}_config", CleaningLabelsConfig(v))
            elif k == "crypto_api_calls":
                super().__setattr__(f"{k}_config", CleaningCryptoAPIConfig(v))
            elif k == "input_paths":
                super().__setattr__("input_paths", [CleaningInputPath(path_conf) for path_conf in v])
            else:
                super().__setattr__(k, v)

def parse_cleaning_config(config: Optional[Dict[str, Any]]) -> Optional[CleaningConfig]:

    print("Parsing cleaning config.")
    result = CleaningConfig(config) if config is not None else None
    if not result.input_paths:
        print("Cleaning config does not contain any input paths.")
        return None
    return result

@dataclass(frozen=True)
class FeatureEngineeringConfig:
    input_json_path: Optional[str] = field(init=False, default=None)
    output_csv_path: Optional[str] = field(init=False, default=None)

    min_ngrams: int = field(init=False, default=1)
    max_ngrams: int = field(init=False, default=5)
    strong_hashes: List[str] = field(
        init=False, 
        default_factory=lambda: ["SHA-1", "SHA-224", "SHA-256", "SHA-384", "SHA-512"])
    use_third_party_packages: bool = field(init=False, default=False)
    use_year: bool = field(init=False, default=False)
    use_tfidf: bool = field(init=False, default=False)
    min_document_frequency: float = field(init=False, default=0.005)
    max_document_frequency: float = field(init=False, default=0.995)
    
    config: InitVar[Dict[str, Any]]

    def __post_init__(self, config: Dict[str, Any]):
        for k, v in config.items():
            super().__setattr__(k, v)

def parse_feature_engineering_config(config: Optional[Dict[str, Any]]) -> Optional[FeatureEngineeringConfig]:

    print("Parsing feature engineering config.")
    result = FeatureEngineeringConfig(config) if config is not None else None
    return result

@dataclass(frozen=True)
class MalwareDetectionRecordsSelectionConfig:
    output_hdf_path: Optional[str] = field(init=False, default=None)

    config: InitVar[Dict[str, Any]]

    def __post_init__(self, config: Dict[str, Any]):
        for k, v in config.items():
            super().__setattr__(k, v)

@dataclass(frozen=True)
class MalwareLabelingRecordsSelectionConfig:
    output_hdf_path: Optional[str] = field(init=False, default=None)
    family_count: int = field(init=False, default=10)
    group_rest: bool = field(init=False, default=True)
    families_to_exclude: List[str] = field(init=False, default_factory=lambda: ["UNKNOWN", "BENIGN"])
    
    config: InitVar[Dict[str, Any]]

    def __post_init__(self, config: Dict[str, Any]):
        for k, v in config.items():
            super().__setattr__(k, v)  

@dataclass(frozen=True)
class RecordsSelectionConfig:
    input_csv_path: Optional[str] = field(init=False, default=None)
    train_set_ratio: float = field(init=False, default=0.9)
    malware_detection_config: Optional[MalwareDetectionRecordsSelectionConfig] = field(init=False, default=None)
    malware_labeling_config: Optional[MalwareLabelingRecordsSelectionConfig] = field(init=False, default=None)
    
    config: InitVar[Dict[str, Any]]

    def __post_init__(self, config: Dict[str, Any]):
        for k, v in config.items():
            if k == "malware_detection":
                super().__setattr__(f"{k}_config", MalwareDetectionRecordsSelectionConfig(v))
            elif k == "malware_labeling":
                super().__setattr__(f"{k}_config", MalwareLabelingRecordsSelectionConfig(v))
            else:
                super().__setattr__(k, v)

def parse_records_selection_config(config: Optional[Dict[str, Any]]) -> Optional[RecordsSelectionConfig]:

    print("Parsing records selection config.")
    result = RecordsSelectionConfig(config) if config is not None else None
    if result is not None and result.malware_detection_config is None and result.malware_labeling_config is None:
        print("There is no malware detection and malware labeling config for records selection.")
        return None
    return result

@dataclass(frozen=True)
class FeatureScalingTaskConfig:
    input_hdf_path: Optional[str] = field(init=False, default=None)
    output_hdf_path: Optional[str] = field(init=False, default=None)

    config: InitVar[Dict[str, Any]]

    def __post_init__(self, config: Dict[str, Any]):
        for k, v in config.items():
            super().__setattr__(k, v)

@dataclass(frozen=True)
class FeatureScalingConfig:
    normalize_by_class_count: bool = field(init=False, default=True)
    normalize_by_lines_of_code: bool = field(init=False, default=False)
    use_standard_scaling: bool = field(init=False, default=False)
    task_configs: Dict[str, FeatureScalingTaskConfig] = field(init=False, default_factory=lambda: dict())
    columns_to_ignore: List[str] = field(init=False, 
        default_factory=lambda: ["metadata_source", "metadata_dex_year", "metadata_n_lines", "metadata_n_classes"]
    )
    
    config: InitVar[Dict[str, Any]]

    def __post_init__(self, config: Dict[str, Any]):
        for k, v in config.items():
            if k == "task_configs":
                for task_name, task_config in v.items():
                    self.task_configs[task_name] = FeatureScalingTaskConfig(task_config)
            else:
                super().__setattr__(k, v)

@dataclass(frozen=True)
class FeatureSelectionTaskConfig:
    input_hdf_path: Optional[str] = field(init=False, default=None)
    output_hdf_path: Optional[str] = field(init=False, default=None)

    config: InitVar[Dict[str, Any]]

    def __post_init__(self, config: Dict[str, Any]):
        for k, v in config.items():
            super().__setattr__(k, v)

def parse_feature_scaling_config(config: Optional[Dict[str, Any]]) -> Optional[FeatureScalingConfig]:

    print("Parsing feature selection config.")
    result = FeatureScalingConfig(config) if config is not None else None
    if result is not None and "malware_detection" not in result.task_configs and "malware_labeling" not in result.task_configs:
        print("There is no malware detection and malware labeling config for feature selection.")
        return None
    return result

@dataclass(frozen=True)
class FeatureSelectionConfig:
    max_iterations: int = field(init=False, default=50)
    use_weak_features_boruta: int = field(init=False, default=True)
    n_trees: int = field(init=False, default=200)
    correlation_threshold: float = field(init=False, default=0.95)
    task_configs: Dict[str, FeatureSelectionTaskConfig] = field(init=False, default_factory=lambda: dict())
    columns_to_ignore: List[str] = field(init=False, 
        default_factory=lambda: ["metadata_source", "metadata_dex_year", "metadata_n_lines", "metadata_n_classes"]
    )
    
    config: InitVar[Dict[str, Any]]

    def __post_init__(self, config: Dict[str, Any]):
        for k, v in config.items():
            if k == "task_configs":
                for task_name, task_config in v.items():
                    self.task_configs[task_name] = FeatureSelectionTaskConfig(task_config)
            else:
                super().__setattr__(k, v)

def parse_feature_selection_config(config: Optional[Dict[str, Any]]) -> Optional[FeatureSelectionConfig]:

    print("Parsing feature selection config.")
    result = FeatureSelectionConfig(config) if config is not None else None
    if result is not None and "malware_detection" not in result.task_configs and "malware_labeling" not in result.task_configs:
        print("There is no malware detection and malware labeling config for feature selection.")
        return None
    return result

@dataclass(frozen=True)
class PreparationConfig:
    
    cleaning: Optional[CleaningConfig]
    feature_engineering: Optional[FeatureEngineeringConfig]
    records_selection: Optional[RecordsSelectionConfig]
    feature_scaling: Optional[FeatureScalingConfig]
    feature_selection: Optional[FeatureSelectionConfig]

def parse_preparation_config(yaml_config_path: str) -> Optional[PreparationConfig]:

    print("Parsing preparation config.")
    with open(yaml_config_path, "r") as handle:
        config_raw = yaml.safe_load(handle)

    result = PreparationConfig(
        cleaning=parse_cleaning_config(config_raw.get("cleaning", None)),
        feature_engineering=parse_feature_engineering_config(config_raw.get("feature_engineering", None)),
        records_selection=parse_records_selection_config(config_raw.get("records_selection", None)),
        feature_scaling=parse_feature_scaling_config(config_raw.get("feature_scaling", None)),
        feature_selection=parse_feature_selection_config(config_raw.get("feature_selection", None))
    )

    # TODO verify if the inputs and sequence makes sense

    return result
