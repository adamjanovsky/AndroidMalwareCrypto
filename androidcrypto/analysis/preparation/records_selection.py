"""
File contains functions used to select relevant samples/records for the objectives.

Author: Dominik Macko
"""

from .config import RecordsSelectionConfig
from typing import List, Dict, Tuple, Optional, Union

import pandas as pd

def select_malware_detection(df: pd.DataFrame,
                             cols_to_drop: List[str]=["metadata_euphony_name", "metadata_euphony_type", "benign"]
                            ) -> Tuple[pd.DataFrame, pd.DataFrame]:
    """Selects only relevant records for malware detection."""
    
    maliciousness = ~df["benign"]
    return (
        df.drop(columns=cols_to_drop),
        maliciousness.to_frame("malicious")
    )

def get_most_popular_families(families: pd.Series, n: int,
                              to_exclude: List[str]=["UNKNOWN", "BENIGN"]
                             ) -> List[str]:
    """Get most popular families from the given series."""
    
    return families[families.apply(lambda f: f not in to_exclude)].value_counts()[:n].index.tolist()

def get_most_popular_malware_families(df: pd.DataFrame, n: int,
                                      to_exclude: List[str]=["UNKNOWN", "BENIGN"]
                                     ) -> List[str]:
    """Get the most popular malware families from the given dataframe."""
    
    return get_most_popular_families(
        df["metadata_euphony_name"],
        n,
        to_exclude
    )

def select_malware_labeling(df: pd.DataFrame,
                            families: List[str],
                            group_rest: bool=True,
                            families_to_filter: List[str]=["UNKNOWN", "BENIGN"],
                            cols_to_drop: List[str]=["metadata_euphony_name", "metadata_euphony_type", "benign"]
                           ) -> Tuple[pd.DataFrame, pd.DataFrame]:
    """Selects only relevant records for labeling of malware families (excluding adware)."""
    
    filtered_df = df[~(df["metadata_euphony_name"].isin(families_to_filter))]
    if group_rest:
        targets = filtered_df["metadata_euphony_name"].apply(
            lambda label: label if label in families else "OTHER")
    else:
        targets = filtered_df[filtered_df["metadata_euphony_name"].isin(families)]["metadata_euphony_name"]
    return (
        filtered_df.drop(columns=cols_to_drop).loc[targets.index],
        pd.DataFrame(
            targets,
            columns=["metadata_euphony_name"]
        )
    )

def records_selection_based_on_config(
    df: Optional[pd.DataFrame],
    config: RecordsSelectionConfig
    ) -> Dict[str, Tuple[pd.DataFrame, pd.DataFrame]]:
    """Performs records selection based on config.
    
    Returns dictionary with task as key and tuple of X, y as value
    """

    print("Records selection: starting.")
    result = {}
    # load if df is None
    if df is None:
        if not config.input_path:
            print("Records selection: No data from previous step and input path not defined.")
            return {}
        print("Records selection: Loading data.")
        df = pd.read_json(config.input_path, orient="index")

    # detection with optional save
    if config.malware_detection_config:
        print("Records selection: Selecting records for malware detection.")
        result["malware_detection"] = select_malware_detection(df)

    # labeling with optional save
    if config.malware_labeling_config:
        print("Records selection: Selecting records for malware labeling.")
        cf = config.malware_labeling_config
        to_select = get_most_popular_malware_families(df, cf.family_count, cf.families_to_exclude)
        result["malware_labeling"] = select_malware_labeling(df, to_select, cf.group_rest, cf.families_to_exclude)

    # return
    return result
