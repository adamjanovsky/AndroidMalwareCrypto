"""
File contains functions used to clean the dataset.

Author: Dominik Macko
"""

from typing import Dict, List, Set, Union, Optional, Tuple, Any
import pandas as pd

from .config import CleaningConfig
from .loading import load_all_json_data

# labels removal

def clean_missing_label(row: pd.Series, label: str) -> pd.Series:
    """Cleans missing label in a row based on benigness of a sample.
    
    When the the label is not None then don't do anything.
    Otherwise, change the label to BENIGN or UNKNWON based on the bool value of column `benign`.
    """
    
    if not pd.isna(row[label]):
        return row
    
    if row["benign"]:
        row[label] = "BENIGN"
    else:
        row[label] = "UNKNOWN"
    return row

def clean_missing_malware_family_name(row: pd.Series) -> pd.Series:
    """Cleans euphony family name of malware for a given row based on benigness of a sample."""
    
    return clean_missing_label(row, "metadata_euphony_name")

def clean_missing_malware_type(row: pd.Series) -> pd.Series:
    """Cleans euphony type of malware for a given row based on benigness of a sample."""
    
    return clean_missing_label(row, "metadata_euphony_type")
    
def safe_drop_column(df: pd.DataFrame, column_name: str) -> None:
    """Safely drops given column from dataframe not triggering error when given column does not exist."""
    
    if column_name in df.columns:
        return df.drop(columns=[column_name])
    return df

def clean_missing_values(df: pd.DataFrame) -> pd.DataFrame:
    """Cleans all missing values from the dataframe inplace."""
    
    # drop columns with only missing values
    df = safe_drop_column(df, "metadata_apk_path")
    df = safe_drop_column(df, "metadata_dx_path")
    
    # create special tags for missing malware family name and malware type
    return df.apply(
        clean_missing_malware_family_name, axis=1).apply(
        clean_missing_malware_type, axis=1)

def convert_str_based_on_rules(s: str, rules: Dict[str, str]) -> str:
    """Converts a string based on a dictionary with rules where each key is changed to val."""
    
    return rules[s] if s in rules else s

def convert_list_based_on_rules(l: List[str], rules: Dict[str, str]) -> List[str]:
    """Convert series' strings based on a dictionary with rules where each key is changed to val."""
    
    return [*map(lambda s: convert_str_based_on_rules(s, rules), l)]

def convert_series_based_on_rules(series: pd.Series, rules: Dict[str, str]) -> pd.Series:
    """Convert series' strings based on a dictionary with rules where each key is changed to val."""
    
    return series.apply(lambda s: convert_str_based_on_rules(s, rules))

def clean_inaccurate_malware_names(series: pd.Series, rules: Dict[str, str]) -> pd.Series:
    """
    Cleans inaccurate malware names based on rules, where key specifies bad type and value specifies desired type.
    """

    return convert_series_based_on_rules(series, rules)

def clean_inaccurate_malware_types(series: pd.Series, rules: Dict[str, str]) -> pd.Series:
    """
    Cleans inaccurate malware types based on rules, where key specifies bad type and value specifies desired type.
    
    note: Also sorts types separated by '++'.
    """
    
    # convert based on rules
    series = convert_series_based_on_rules(series, rules)
    # split on '++', normalize by sorting, convert based on rules and then join with "++"
    series = series.apply(lambda s: "++".join(convert_list_based_on_rules(sorted(s.split("++")), rules)))
    # just in case convert based on rules once again
    return convert_series_based_on_rules(series, rules)

def build_label_relationship_dict(df: pd.DataFrame,
                                  names_to_ignore: List[str]=["UNKNOWN, BENIGN"]
                                 ) -> Dict[str, str]:
    """Builds a dictionary which contains as key malware family name and as value most often occuring malware type."""
    
    mappings = pd.crosstab(df["metadata_euphony_name"], df["metadata_euphony_type"])
    result = mappings.idxmax(axis=1).to_dict()
    # we ignore some special names (by default UNKNOWN and BENIGN)
    return { mname: mtype for mname, mtype in result.items() if mname not in names_to_ignore }

def clean_mismatched_malware_family_type(row: pd.Series, name_to_type: Dict[str, str]) -> pd.Series:
    """Cleans mismatched malware family type based on name to type dictionary."""
    
    desired_type = name_to_type.get(row["metadata_euphony_name"], None)
    if desired_type is not None:
        row["metadata_euphony_type"] = desired_type
    return row

def clean_label_relationships(df : pd.DataFrame, name_to_type: Dict[str, str]) -> pd.DataFrame:
    """Cleans malware family and type relationship by changing type based on each mapping in dictionary."""
    
    return df.apply(lambda row: clean_mismatched_malware_family_type(row, name_to_type), axis=1)

# third party packages removal

def remove_subset(subset_series : pd.Series, series : pd.Series) -> pd.Series:
    """Removes all values from subset series from series. Values need to be convertible to set."""
    
    return series.apply(set) - subset_series.apply(set)

def clean_non_crypto_third_party_packages_duplicit_info(third_party_crypto_libs: pd.Series,
                                                        third_party_packages: pd.Series) -> pd.Series:
    """Removes third party crypto libs from third party packages to remove duplicit information."""
    
    return remove_subset(third_party_crypto_libs, third_party_packages)

# classes (keys) removal 

def find_groupped_index(groupping_list : List[Tuple[Any, List[str]]], key_to_check : Any) -> int:
    """Finds index of key in given list of tuples where first element of tuple is key."""
    
    for i, (key, _) in enumerate(groupping_list):
        if key == key_to_check:
            return i
    return -1
            

def group_dict_by_value(dictionary : Dict[str, Any]) -> List[Tuple[Any, List[str]]]:
    """Groups dictionary by value and returns it as a list of tuples."""
    
    groupped_tuples = []
    for key, value_list in dictionary.items():
        i = find_groupped_index(groupped_tuples, value_list)
        if i == -1: # not found
            groupped_tuples.append((value_list, [key]))
        else:
            groupped_tuples[i][1].append(key)
    return groupped_tuples
    
def keys_remove_dollar_suffixes(keys : List[str]) -> List[str]:
    """Removes dollar suffixes from keys."""
    
    result = []
    for key in keys:
        i = key.find("$")
        if i != -1:
            result.append(key[:i])
        else:
            result.append(key)
    return result

def remove_similar_keys(keys : List[str]) -> List[str]:
    """Remove similar keys."""
    
    return list(set(keys_remove_dollar_suffixes(keys)))

def crypto_api_dict_remove_similar_keys(records : Dict[str, List[List[Union[str, int]]]]
                                        ) -> Dict[str, List[List[Union[str, int]]]]:
    """Remove similar keys from crypto api records dict."""
    
    if pd.isna(records):
        return records
    
    groupped = group_dict_by_value(records)
    groupped = list(map(lambda x: (x[0], remove_similar_keys(x[1])), groupped))
    
    result = dict()
    for value_list, keys in groupped:
        for key in keys:
            result[key] = value_list
    return result

def clean_duplicate_crypto_api_records_keys(df : pd.DataFrame) -> pd.DataFrame:
    """Cleans duplicate crypto api records keys in place."""
    
    df["crypto_api_records"] = df["crypto_api_records"].apply(
        lambda dictionary: crypto_api_dict_remove_similar_keys(dictionary))
    return df

# crypto api calls removal

def filter_duplicate_constructors(constructors : List[str]) -> List[str]:
    """Filters duplicate constructors based on whether it is a prefix of other constructor."""
    
    result = []
    # first sort constructors in ascending order by their length 
    constructors.sort(key=lambda x: len(x))
    # for each constructor check if it is not prefix of a longer constructor
    # if not then add it to result
    for i in range(len(constructors)):
        add = True
        shorter = constructors[i]
        for j in range(i+1, len(constructors)):
            longer = constructors[j]
            if shorter in longer:
                add = False
        if add:
            result.append(shorter)
    return result

def crypto_api_value_list_remove_duplicates(value_list: List[List[Union[str, int]]]
                                           ) -> List[Tuple[str, str, int]]:
    """Removes duplicates for a given crypto api records value list."""
    
    # group constructors by line and line index
    groupped = dict()
    for value in value_list:
        constructor, line, line_index = value
        key = (line, line_index)
        if key not in groupped:
            groupped[key] = []
        groupped[key].append(constructor)
    
    # remove duplicate in constructors list groupped by line and line index
    groupped_items = [*groupped.items()]
    groupped_items = [*map(
        lambda x: (x[0][0], x[0][1], filter_duplicate_constructors(x[1])), groupped_items)]
    
    # build value list back together, but change it to list of tuples
    result = []
    for line, line_index, constructors in groupped_items:
        for constructor in constructors:
            result.append((constructor.strip(), line.strip(), line_index))
    return result  

def crypto_api_dict_remove_duplicate_entries(records: Dict[str, List[List[Union[str, int]]]]
                                            ) -> Dict[str, List[List[Union[str, int]]]]:
    """Removes duplicate entries for a given crypto api records dictionary."""
    
    if pd.isna(records):
        return records
    
    return {
        k: crypto_api_value_list_remove_duplicates(vl) for k, vl in records.items()
    }

def clean_duplicate_crypto_api_records_entries(df: pd.DataFrame) -> pd.DataFrame:
    """Cleans duplicate crypto api records entries in place."""
    
    df["crypto_api_records"] = df["crypto_api_records"].apply(
        crypto_api_dict_remove_duplicate_entries)
    return df

def constructor_is_method_name(constructor: str) -> bool:
    """Decides wheter given constructor is a method name.
    
    Cipher is not a method name
    Cipher.getInstance is a method name
    getS is a method name
    """
    
    found_index = constructor.find(".")
    method_start_i = found_index + 1
    return len(constructor) > method_start_i and constructor[method_start_i].islower()
    
def constructor_method_name_is_false_positive(constructor: str, line: str) -> bool:
    """Decides whether given constructor method is false positive.
    
    if method does not contain "." in it (for example `getS()`) then it must be before it (`.getS()`)
    if method contains "." then before it should not be alpha but " " or "(" (for example `Cipher.getInstance(`)
    """
    
    # method needs to be prefixed with .
    if "." not in constructor:
        return f".{constructor}" not in line
    found_index = line.find(constructor)
    # constructor not found
    if found_index < 0:
        return True
    # method with class prefix needs to be prefixed by something not alpha numerical (space, bracket etc)
    return found_index != 0 and (line[found_index-1].isalnum() or line[found_index-1] in ["_", "."])

def constructor_class_name_is_false_positive(constructor: str, line: str) -> bool:
    """Decides whether given class name constructor is false positive.
    
    Class name constructor must be in the format `new constructor` (for example `new KeyPair`)
    """
    
    return f"new {constructor}" not in line

def crypto_api_records_entry_is_false_positive(entry: List[Union[str, int]]) -> bool:
    """Checks whether given entry is false positive."""

    constructor = entry[0]
    line = entry[1]
    # method name
    if constructor_is_method_name(constructor):
        return constructor_method_name_is_false_positive(constructor, line)
    return constructor_class_name_is_false_positive(constructor, line)

def crypto_api_records_filter_false_positives(entries: List[List[Union[str, int]]],
                                              constructors_to_filter: Set[str]
                                             ) -> List[List[Union[str, int]]]:
    """Filters false positives and constructors specified from given list of entries."""

    return [
        vl for vl in entries if vl[0] not in constructors_to_filter and (
            not crypto_api_records_entry_is_false_positive(vl))
    ]

def crypto_api_dict_remove_false_positives(records: Dict[str, List[List[Union[str, int]]]],
                                           constructors_to_filter: Set[str]
                                            ) -> Dict[str, List[List[Union[str, int]]]]:
    """Removes false positives from crypto api dict."""

    result = {
        k: crypto_api_records_filter_false_positives(
            v, constructors_to_filter) for k, v in records.items()
    }
    # filter out classes that now have everything missing
    return {
        k: v for k, v in result.items() if v
    }

def clean_false_positive_crypto_api_records_entries(df: pd.DataFrame,
                                                    constructors_to_filter: Set[str]
                                                   ) -> pd.DataFrame:
    """Cleans false positive crypto api records entries."""

    df["crypto_api_records"] = df["crypto_api_records"].apply(
        lambda d: crypto_api_dict_remove_false_positives(d, constructors_to_filter))
    return df
    
def clean_crypto_api_records_empty_imports_row(row: pd.Series) -> pd.Series:
    """Cleans (empties) crypto api records of a row if crypto imports are empty."""
    
    if not row["crypto_imports"]:
        row["crypto_api_records"] = {}
    return row
    
def clean_crypto_api_records_empty_imports(df: pd.DataFrame) -> pd.DataFrame:
    """Cleans situations when crypto_imports are empty but crypto_api_records are not."""
    
    return df.apply(clean_crypto_api_records_empty_imports_row, axis=1)
    
def clean_crypto_api_records_entries(df: pd.DataFrame,
                                     constructors_to_filter: Set[str]={
                                         "Cipher",
                                         "PRIVATE_KEY",
                                         "SECRET_KEY",
                                         "PUBLIC_KEY",
                                         "ENCRYPT_MODE"
                                     }
                                    ) -> pd.DataFrame:
    """Cleans crypto api records value entries."""
    
    df = clean_crypto_api_records_empty_imports(df)
    df = clean_duplicate_crypto_api_records_entries(df)
    df = clean_false_positive_crypto_api_records_entries(df, constructors_to_filter)
    
    return df

def clean_based_on_config(config: CleaningConfig) -> pd.DataFrame:
    """"Cleans based on a config file."""

    # load
    print("Cleaning: Loading data.")
    df = load_all_json_data(config.input_malicious_paths, config.input_benign_paths)

    # missing values
    print("Cleaning: Missing values.")
    df = clean_missing_values(df)

    # labels
    if config.labels_config:
        print("Cleaning: Labels.")
        df["metadata_euphony_name"] = clean_inaccurate_malware_names(df["metadata_euphony_name"], config.labels_config.name_rules)
        df["metadata_euphony_type"] = clean_inaccurate_malware_types(df["metadata_euphony_type"], config.labels_config.type_rules)
        name_to_type = build_label_relationship_dict(df, config.labels_config.names_to_ignore_during_mapping)
        df = clean_label_relationships(df, name_to_type)

    # third party packages
    if config.remove_third_party_crypto_from_packages:
        print("Cleaning: Third party packages.")
        df["third_party_packages"] = clean_non_crypto_third_party_packages_duplicit_info(
            df["third_party_crypto_libs"], df["third_party_packages"])

    # crypto API records classes
    if config.remove_similar_records_classes:
        print("Cleaning: Duplicate (similar) crypto API records keys (classes).")
        df = clean_duplicate_crypto_api_records_keys(df)

    # crypto API calls
    if config.crypto_api_calls_config:
        print("Cleaning: Crypto API records calls.")
        if config.crypto_api_calls_config.remove_when_imports_empty:
            print("Cleaning: Removing crypto API calls.")
            df = clean_crypto_api_records_empty_imports(df)
        if config.crypto_api_calls_config.remove_duplicates:
            print("Cleaning: Removing crypto API duplicates.")
            df = clean_duplicate_crypto_api_records_entries(df)
        if config.crypto_api_calls_config.remove_false_positives:
            print("Cleaning: Removing crypto API false positives.")
            df = clean_false_positive_crypto_api_records_entries(df, set(config.crypto_api_calls_config.calls_to_filter))

    # optionally save
    if config.output_path:
        print("Cleaning: Saving data.")
        df.to_json(config.output_path, orient="index")

    # return
    return df
