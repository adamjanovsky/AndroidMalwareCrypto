from dataclasses import InitVar, dataclass, field
from typing import List, Dict, Any, Optional
import yaml

@dataclass(frozen=True)
class ExplainabilityConfig:

    model_path: str = field(init=False, default="")
    values_path: str = field(init=False, default="")
    target_path: Optional[str] = field(init=False, default=None)
    sample_size: int = field(init=False, default=-1)
    indices: Optional[List[int]] = field(init=False, default=None)

    feature_pertubation: str = field(init=False, default="tree_path_dependent")
    model_output: str = field(init=False, default="raw")
    approximate: bool = field(init=False, default=False)
    calculate_shap_values: bool = field(init=False, default=True)
    calculate_interaction_values: bool = field(init=False, default=False)

    save_values: bool = field(init=False, default=True)
    save_targets: bool = field(init=False, default=True)
    save_hashes: bool = field(init=False, default=True)

    output_path: str = field(init=False, default="")
    output_explainer_path: Optional[str] = field(init=False, default=None)

    config: InitVar[Dict[str, Any]]

    def __post_init__(self, config: Dict[str, Any]):
        for k, v in config.items():
            super().__setattr__(k, v)

def parse_explainability_config(yaml_config_path: str) -> Optional[ExplainabilityConfig]:

    print("Parsing explainability config.")
    with open(yaml_config_path, "r") as handle:
        config_raw = yaml.safe_load(handle)

    result = ExplainabilityConfig(
        config_raw
    )
    to_return = result

    if not result.input_model_path:
        print("Invalid config: No input model path.")
        to_return = None
    if not result.values_path:
        print("Invalid config: No input values path.")
        to_return = None
    if not result.output_path:
        print("Invalid config: No output path.")
        to_return = None

    return to_return
