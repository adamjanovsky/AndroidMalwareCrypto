from typing import Dict, Optional, Tuple, Any

import pandas as pd

from .config import TrainingConfig, TrainingTaskConfig
from .random_forest import train_random_forest_based_on_config
from .lgbm import train_lgbm_based_on_config
from .svm import train_svm_based_on_config
from .naive_bayes import train_gnb_based_on_config, train_cnb_based_on_config
from .logistic_regression import train_logistic_regression_based_on_config
from .lda import train_lda_based_on_config
from .explainable_boosting import train_explainable_boosting_based_on_config
from .decision_rule_list import train_decision_list_based_on_config

RANDOM_FOREST_NAMES = ["rf", "random_forest", "random forest"]
LGBM_NAMES = ["lgbm"]
SVM_NAMES = ["svm", "support_vector_machines", "support_vector_machine", "support vector machine", "support vector machines"]
GAUSSIAN_NAIVE_BAYES_NAMES = ["gnb", "gaussian_naive_bayes", "gaussian naive bayes", "gaussian_nb", "gaussian nb"]
COMPLEMENT_NAIVE_BAYES_NAMES = ["cnb", "complement_naive_bayes", "complement naive bayes", "complement_nb", "complement nb"]
MLP_NAMES = ["mlp", "multilayer_perceptron", "multilayer perceptron"]
LOGISTIC_REGRESSION_NAMES = ["lr", "logistic_regression", "logistic regression"]
LDA_NAMES = ["lda", "linear_discriminant_analysis", "linear discriminant analysis"]
EXPLAINABLE_BOOSTING_NAMES = ["eb", "ebm", "explainable_boosting", "explainable boosting"]
DECISION_RULE_LIST_NAMES = ["rules"]

def train_task(input_train_features: pd.DataFrame,
               input_train_target: pd.Series,
               input_test_features: Optional[pd.DataFrame], 
               task_name: str,
               task_config: TrainingTaskConfig,
               cv_splits: int,
               threads: int
               ) -> Optional[Tuple[Any, Optional[pd.DataFrame]]]:

    task_name_standartized = task_name.lower().strip()
    if task_name_standartized in RANDOM_FOREST_NAMES:
        return train_random_forest_based_on_config(input_train_features, input_train_target,
                                                   input_test_features, task_config, cv_splits, threads)
    elif task_name_standartized in LGBM_NAMES:
        return train_lgbm_based_on_config(input_train_features, input_train_target, 
                                          input_test_features, task_config, cv_splits, threads)
    elif task_name_standartized in SVM_NAMES:
        return train_svm_based_on_config(input_train_features, input_train_target, 
                                          input_test_features, task_config, cv_splits, threads)
    elif task_name_standartized in GAUSSIAN_NAIVE_BAYES_NAMES:
        return train_gnb_based_on_config(input_train_features, input_train_target, 
                                          input_test_features, task_config)
    elif task_name_standartized in COMPLEMENT_NAIVE_BAYES_NAMES:
        return train_cnb_based_on_config(input_train_features, input_train_target, 
                                          input_test_features, task_config, cv_splits, threads)
    elif task_name_standartized in MLP_NAMES:
        from .mlp import train_mlp_based_on_config # import here to not trigger imports if not needed
        return train_mlp_based_on_config(input_train_features, input_train_target, 
                                          input_test_features, task_config, cv_splits, threads)
    elif task_name_standartized in LOGISTIC_REGRESSION_NAMES:
        return train_logistic_regression_based_on_config(input_train_features, input_train_target, 
                                                         input_test_features, task_config, cv_splits, threads)
    elif task_name_standartized in LDA_NAMES:
        return train_lda_based_on_config(input_train_features, input_train_target, 
                                         input_test_features, task_config)
    elif task_name_standartized in EXPLAINABLE_BOOSTING_NAMES:
        return train_explainable_boosting_based_on_config(input_train_features, input_train_target, 
                                                         input_test_features, task_config, cv_splits, threads)
    elif task_name_standartized in DECISION_RULE_LIST_NAMES: 
        return train_decision_list_based_on_config(input_train_features, input_train_target, 
                                                  input_test_features, task_config, cv_splits, threads)

    print(f"Training: Task {task_name} is not recognized")
    return None


def train_tasks(input_train_features: pd.DataFrame,
                input_train_target: pd.Series,
                input_test_features: Optional[pd.DataFrame], 
                configs: Dict[str, TrainingTaskConfig],
                cv_splits: int,
                threads: int
                ) -> Dict[str, Tuple[Any, Optional[pd.DataFrame]]]:


    result = {}
    for task_name, task_config in configs.items():
        result[task_name] = train_task(input_train_features, input_train_target, 
                                        input_test_features, task_name, task_config, cv_splits, threads)
    return result


def train_based_on_config(config: TrainingConfig) -> Dict[str, Tuple[Any, Optional[pd.DataFrame]]]:

    print("Training: Loading data.")
    input_train_features = pd.read_csv(config.input_train_features_path, index_col=0, squeeze=True)
    input_train_target = pd.read_csv(config.input_train_target_path, index_col=0, squeeze=True)
    input_test_features = None
    if config.input_test_features_path:
        print("Training: Loading optional test features data.")
        input_test_features = pd.read_csv(config.input_test_features_path, index_col=0, squeeze=True)
    
    return train_tasks(input_train_features, input_train_target, input_test_features, config.task_configs, config.cv_splits, config.threads)
