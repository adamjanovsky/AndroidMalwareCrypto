from typing import Dict, Optional, Tuple, Any

import pandas as pd

from androidcrypto.analysis.training.config import TrainingConfig, TrainingTaskConfig
from androidcrypto.analysis.training.random_forest import train_random_forest_based_on_config
from androidcrypto.analysis.training.lgbm import train_lgbm_based_on_config
from androidcrypto.analysis.training.svm import train_svm_based_on_config
from androidcrypto.analysis.training.naive_bayes import train_gnb_based_on_config, train_cnb_based_on_config
from androidcrypto.analysis.training.logistic_regression import train_logistic_regression_based_on_config
from androidcrypto.analysis.training.lda import train_lda_based_on_config
from androidcrypto.analysis.training.explainable_boosting import train_explainable_boosting_based_on_config
from androidcrypto.analysis.training.decision_rule_list import train_decision_list_based_on_config

RANDOM_FOREST_NAMES = ["rf", "random_forest", "random forest"]
LGBM_NAMES = ["lgbm"]
SVM_NAMES = ["svm", "support_vector_machines", "support_vector_machine", "support vector machine", "support vector machines"]
GAUSSIAN_NAIVE_BAYES_NAMES = ["gnb", "gaussian_naive_bayes", "gaussian naive bayes", "gaussian_nb", "gaussian nb"]
COMPLEMENT_NAIVE_BAYES_NAMES = ["cnb", "complement_naive_bayes", "complement naive bayes", "complement_nb", "complement nb"]
LOGISTIC_REGRESSION_NAMES = ["lr", "logistic_regression", "logistic regression"]
LDA_NAMES = ["lda", "linear_discriminant_analysis", "linear discriminant analysis"]
EXPLAINABLE_BOOSTING_NAMES = ["eb", "ebm", "explainable_boosting", "explainable boosting"]
DECISION_RULE_LIST_NAMES = ["rules"]

def train_task(input_train_features: pd.DataFrame,
               input_train_target: pd.Series,
               input_test_features: Optional[pd.DataFrame], 
               task_name: str,
               task_config: TrainingTaskConfig,
               cv_splits: int,
               threads: int
               ) -> Optional[Tuple[Any, Optional[pd.DataFrame]]]:

    task_name_standartized = task_name.lower().strip()
    if task_name_standartized in RANDOM_FOREST_NAMES:
        return train_random_forest_based_on_config(input_train_features, input_train_target,
                                                   input_test_features, task_config, cv_splits, threads)
    elif task_name_standartized in LGBM_NAMES:
        return train_lgbm_based_on_config(input_train_features, input_train_target, 
                                          input_test_features, task_config, cv_splits, threads)
    elif task_name_standartized in SVM_NAMES:
        return train_svm_based_on_config(input_train_features, input_train_target, 
                                          input_test_features, task_config, cv_splits, threads)
    elif task_name_standartized in GAUSSIAN_NAIVE_BAYES_NAMES:
        return train_gnb_based_on_config(input_train_features, input_train_target, 
                                          input_test_features, task_config)
    elif task_name_standartized in COMPLEMENT_NAIVE_BAYES_NAMES:
        return train_cnb_based_on_config(input_train_features, input_train_target, 
                                          input_test_features, task_config, cv_splits, threads)
    elif task_name_standartized in LOGISTIC_REGRESSION_NAMES:
        return train_logistic_regression_based_on_config(input_train_features, input_train_target, 
                                                         input_test_features, task_config, cv_splits, threads)
    elif task_name_standartized in LDA_NAMES:
        return train_lda_based_on_config(input_train_features, input_train_target, 
                                         input_test_features, task_config)
    elif task_name_standartized in EXPLAINABLE_BOOSTING_NAMES:
        return train_explainable_boosting_based_on_config(input_train_features, input_train_target, 
                                                         input_test_features, task_config, cv_splits, threads)
    elif task_name_standartized in DECISION_RULE_LIST_NAMES: 
        return train_decision_list_based_on_config(input_train_features, input_train_target, 
                                                  input_test_features, task_config, cv_splits, threads)

    print(f"Training: Task {task_name} is not recognized")
    return None


def train_tasks(input_train_features: pd.DataFrame,
                input_train_target: pd.Series,
                input_test_features: Optional[pd.DataFrame], 
                configs: Dict[str, TrainingTaskConfig],
                cv_splits: int,
                threads: int
                ) -> Dict[str, Tuple[Any, Optional[pd.DataFrame]]]:


    result = {}
    for task_name, task_config in configs.items():
        result[task_name] = train_task(input_train_features, input_train_target, 
                                        input_test_features, task_name, task_config, cv_splits, threads)
    return result


def train_based_on_config(config: TrainingConfig) -> Dict[str, Tuple[Any, Optional[pd.DataFrame]]]:

    print("Training: Loading data.")
    input_train_features = pd.read_hdf(config.input_hdf_path, key="X_train")
    input_train_target = pd.read_csv(config.input_hdf_path, key="y_train").squeeze("columns")
    input_test_features = pd.read_hdf(config.input_hdf_path, key="X_test")
    
    return train_tasks(input_train_features, input_train_target, input_test_features, config.task_configs, config.cv_splits, config.threads)
