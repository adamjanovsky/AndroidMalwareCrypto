
from dataclasses import InitVar, dataclass, field
from typing import List, Dict, Any, Optional
import yaml

@dataclass(frozen=True)
class TrainingTaskConfig:

    output_model_path: Optional[str] = field(init=False, default=None)
    output_prediction_path: Optional[str] = field(init=False, default=None)

    config: InitVar[Dict[str, Any]]

    def __post_init__(self, config: Dict[str, Any]):
        for k, v in config.items():
            super().__setattr__(k, v)


@dataclass(frozen=True)
class TrainingConfig:
    
    input_train_features_path: str = field(init=False, default=None)
    input_train_target_path: str = field(init=False, default=None)
    input_test_features_path: Optional[str] = field(init=False, default=None)
    cv_splits: int = field(init=False, default=5)
    threads: int = 8
    task_configs: Dict[str, TrainingTaskConfig] = field(init=False, default_factory=lambda: dict())

    config: InitVar[Dict[str, Any]]

    def __post_init__(self, config: Dict[str, Any]):
        for k, v in config.items():
            if k == "task_configs":
                for task_name, task_config in v.items():
                    self.task_configs[task_name] = TrainingTaskConfig(task_config)
            else:
                super().__setattr__(k, v)

def parse_training_config(yaml_config_path: str) -> Optional[TrainingConfig]:

    with open(yaml_config_path, "r") as handle:
        config_raw = yaml.safe_load(handle)

    result = TrainingConfig(
        config_raw
    )

    if result.input_train_features_path is None or result.input_train_target_path is None:
        print("Training config must contain paths to feature and target training datasets.")
        return None

    return result
