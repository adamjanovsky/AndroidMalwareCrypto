import os
import androidcrypto.constants as constants
import androidcrypto.helpers as helpers
from importlib import reload
import logging
import neptune
from time import gmtime, strftime
from datetime import datetime
from multiprocessing import Pool
from tqdm import tqdm


class Task:
    """
    Partially abstract class. It covers general case of running a task that comprises of:
    1) Initializing Neptune.ml experiment and local folder with results
    2) running the experiment on each of the datasets
        - where 'running on a dataset' is an abstract function
    3) Uploading the experiment artifacts to the Neptune.ml service
    4) Terminating the experiment

    Specific cases are extended by child classes
    """
    def __init__(self, experiment_config):
        self.cfg = experiment_config
        self.current_dataset = None
        self.experiment = None
        self.experiment_id = 'untitled'
        self.processed_samples = 0
        self.dset_start_time = datetime.now()
        self.pbar = None

    def init_neptune(self):
        """
        Creates new Neptune experiment and prepares folder to store results into
        """
        if self.cfg.is_being_logged:
            logging.info('Creating neptune experiment')
            neptune.init(project_qualified_name=self.cfg.neptune_project_name,
                         api_token=self.cfg.neptune_api_token)
            self.experiment = neptune.create_experiment(name=self.cfg.experiment_name)

            for dset in self.cfg.datasets:
                self.experiment.set_property(dset.name + ' version', dset.sha_digest)
                self.experiment.append_tag(dset.name)

            self.cfg.experiment_id = str(self.experiment.id)
            self._update_folder_structure(self.cfg.experiment_id)
        else:
            suffix_dirname = strftime("%Y%m%dt%H%M%S", gmtime())
            self._update_folder_structure(suffix_dirname)

    def _update_folder_structure(self, suffix_dirname):
        """
        Moves folder from temporary path to the folder with the ID of the experiment
        """
        logging.info('Updating folder structure.')
        old_logging_path = self.cfg.logging_path
        self.cfg.output_path = os.path.join(self.cfg.output_path, suffix_dirname)
        os.mkdir(self.cfg.output_path)
        self.cfg.logging_path = os.path.join(self.cfg.output_path, constants.LOGS_FILENAME)
        self._move_logging(old_logging_path, self.cfg.logging_path)

    @staticmethod
    def _move_logging(src, dst):
        """
       Moves logging file from src filepath to dst filepath (done when folder with results is established).
       :param src: destination to move from
       :param dst: destination to move to
       :return: Nothing
       """
        reload(logging)
        os.rename(src, dst)
        logging.basicConfig(filename=dst, level=logging.INFO, filemode='a',
                            format='%(asctime)s - %(levelname)s - %(funcName)s - %(message)s')

    def run(self):
        """
        Runs the experiment on all datasets
        :return:
        """
        self.init_neptune()
        for dset in self.cfg.datasets:
            self.current_dataset = dset
            self.run_on_dataset(dset)
        self.eval_neptune()

    def run_on_dataset(self, dset):
        self.dset_start_time = datetime.now()
        self.update_neptune_progress()

        process_pool = Pool(self.cfg.n_threads)
        with tqdm(total=self.current_dataset.n_samples) as self.pbar:
            for smpl in dset.generator():
                process_pool.apply_async(self.worker, (smpl,), callback=self.worker_callback)
            process_pool.close()
            process_pool.join()

        self.update_neptune_progress()

    # IMPORTANT: Any implementation must implement this as a static method, otherwise, parallelism will fail.
    @staticmethod
    def worker(sample):
        raise NotImplementedError('Abstract method -- not meant to be implemented.')

    def clean_up_after_dataset(self):
        raise NotImplementedError('Abstract method -- not meant to be implemented.')

    def worker_callback(self, result):
        self.pbar.update()
        # TODO: Maybe decrease granularity if the load is too heavy on time
        if not self.processed_samples % 10 and self.cfg.is_being_logged is True:
            self.update_neptune_progress()
        self.processed_samples += 1

    def update_neptune_progress(self):
        curr_time = datetime.now()
        fraction = self.processed_samples / self.current_dataset.n_samples
        self.experiment.log_metric('progress', (curr_time - self.dset_start_time).total_seconds(), y=fraction)

    def eval_neptune(self):
        """
        Uploads the experiment artifacts into the Neptune.ml
        :return:
        """
        if self.cfg.is_being_logged:
            self.cfg.logger.info('Uploading experiment to Neptune.ml')
            neptune.send_artifact(self.cfg.logging_path)
            neptune.send_artifact(self.cfg.config_path)
            neptune.stop()
