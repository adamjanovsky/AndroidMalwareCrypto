import os
from tqdm import tqdm
import androidcrypto.constants as constants
from importlib import reload
import logging
import neptune
from time import gmtime, strftime
from multiprocessing.dummy import Pool as ThreadPool


class Task:
    """
    Partially abstract class. It covers general case of running a task that comprises of:
    1) Initializing Neptune.ml experiment and local folder with results
    2) running the experiment on each of the datasets
        - where 'running on a dataset' is an abstract function
    3) Uploading the experiment artifacts to the Neptune.ml service
    4) Terminating the experiment

    Specific cases are extended by child classes
    """
    def __init__(self, experiment_config):
        self.cfg = experiment_config
        self.current_dataset = None
        self.experiment = None
        self.experiment_id = 'untitled'
        self.experiment_data = []

    def init_neptune(self):
        """
        Creates new Neptune experiment and prepares folder to store results into
        """
        if self.cfg.is_being_logged:
            logging.info('Creating neptune experiment')
            neptune.init(project_qualified_name=self.cfg.neptune_project_name,
                         api_token=self.cfg.neptune_api_token)
            self.experiment = neptune.create_experiment(name=self.cfg.experiment_name)

            for dset in self.cfg.datasets:
                self.experiment.set_property(dset.name + ' version', dset.sha_digest)
                self.experiment.append_tag(dset.name)

            self.cfg.experiment_id = str(self.experiment.id)
            self._update_folder_structure(self.cfg.experiment_id)
        else:
            suffix_dirname = strftime("%Y%m%dt%H%M%S", gmtime())
            self._update_folder_structure(suffix_dirname)

    def _update_folder_structure(self, suffix_dirname):
        """
        Moves folder from temporary path to the folder with the ID of the experiment
        """
        logging.info('Updating folder structure.')
        old_logging_path = self.cfg.logging_path
        self.cfg.output_path = os.path.join(self.cfg.output_path, suffix_dirname)
        os.mkdir(self.cfg.output_path)
        self.cfg.logging_path = os.path.join(self.cfg.output_path, constants.LOGS_FILENAME)
        self._move_logging(old_logging_path, self.cfg.logging_path)

    @staticmethod
    def _move_logging(src, dst):
        """
       Moves logging file from src filepath to dst filepath (done when folder with results is established).
       :param src: destination to move from
       :param dst: destination to move to
       :return: Nothing
       """
        reload(logging)
        os.rename(src, dst)
        logging.basicConfig(filename=dst, level=logging.INFO, filemode='a',
                            format='%(asctime)s - %(levelname)s - %(funcName)s - %(message)s')

    def run(self):
        """
        Runs the experiment on all datasets
        :return:
        """
        self.init_neptune()
        for dset in self.cfg.datasets:
            self.current_dataset = dset
            self.run_on_dataset(dset)
        self.eval_neptune()

    def run_on_dataset(self, dset):
        pool = ThreadPool(self.cfg.n_threads)

        # According to stack overflow, has to be started twice
        with tqdm(total=dset.n_samples) as progress_bar:
            for i, val in tqdm(enumerate(pool.imap_unordered(self.worker, dset.generator())), total=dset.n_samples,
                             position=0, leave=True):
                self.experiment_data.append(val)
                progress_bar.update()

    def worker(self, sample):
        raise NotImplementedError('Abstract method -- not meant to be implemented.')

    def eval_neptune(self):
        """
        Uploads the experiment artifacts into the Neptune.ml
        :return:
        """
        if self.cfg.is_being_logged:
            self.cfg.logger.info('Uploading experiment to Neptune.ml')
            neptune.send_artifact(self.cfg.logging_path)
            neptune.send_artifact(self.cfg.config_path)
            neptune.stop()
