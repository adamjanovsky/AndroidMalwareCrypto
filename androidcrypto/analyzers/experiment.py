import os
import androidcrypto.constants as constants
import neptune
from time import gmtime, strftime
import lzma
import pickle
import androidcrypto.helpers as helpers
from datetime import datetime, timedelta
from multiprocessing import Pool
from tqdm import tqdm
import sys

from androidcrypto.workers.decompile import decompile_worker


class Experiment:
    def __init__(self, experiment_config):
        self.cfg = experiment_config
        self.dset = self.cfg.dset
        self.experiment = None
        self.experiment_id = 'untitled'
        self.processed_samples = 0
        self.start_time = datetime.now()
        self.last_update_time = datetime.now()
        self.pbar = None
        self.progress_metric_name = 'progress'
        self.process_pool = None
        self.tasks = self.cfg.tasks

        self.delete_apks = False  # TODO: Resolve this
        self.delete_dxs = False # TODO: Implement
        self.failed_samples = []
        self.custom_jadx_path = 'jadx'  # TODO: Resolve this

        self.current_task = None
        self.pbar = None

    def init_neptune(self):
        if self.cfg.is_being_logged:
            neptune.init(project_qualified_name=self.cfg.neptune_project_name,
                         api_token=self.cfg.neptune_api_token)
            self.experiment = neptune.create_experiment(name=self.cfg.experiment_name)

            self.experiment.set_property(self.dset.name + ' version', self.dset.sha_digest)
            self.experiment.append_tag(self.dset.name)

            self.cfg.experiment_id = str(self.experiment.id)

    def prepare_experiment(self):
        if constants.TASK_DOWNLOAD in self.tasks:
            if self.dset.apk_available is True:
                print(f'Error: apks already available while trying to download others...')
                sys.exit()
            self.dset.prepare_download()

            if constants.TASK_DECOMPILE in self.tasks:
                self.dset.prepare_apk_paths()

        if constants.TASK_DECOMPILE in self.tasks:
            if self.dset.dx_available is True:
                print(f'Error: dxs already available while trying to decompile...')
                sys.exit()
            self.dset.prepare_dx_paths()

        # TODO: Add another checks for crypto evaluation if needed

    def run(self):
        self.init_neptune()

        if constants.TASK_DOWNLOAD in self.tasks:
            self.dset.prepare_download(self.cfg.task_configs[constants.TASK_DOWNLOAD])
            self.dset.prepare_apk_paths()

        if constants.TASK_DECOMPILE in self.tasks:
            self.dset.prepare_dx_paths()

        process_pool = Pool(self.cfg.n_threads)
        with tqdm(total=self.dset.n_samples) as self.pbar:
            for sample_id, sample_record in self.dset.generator_json():
                #result = self.super_worker(sample_id, sample_record, self.tasks)
                #self.super_worker_callback(result)
                process_pool.apply_async(self.super_worker, (sample_id, sample_record, self.tasks), callback=self.super_worker_callback)
        process_pool.close()
        process_pool.join()

        if self.delete_apks is False and (self.dset.apk_available is True or constants.TASK_DOWNLOAD in self.tasks):
            self.dset.apk_available = True
        if self.delete_dxs is False and (self.dset.dx_available is True or constants.TASK_DECOMPILE in self.tasks):
            self.dset.dx_available = True

        self.dset.n_samples -= len(self.failed_samples)
        self.dset.update_meta()

        self.eval_neptune()

    @staticmethod
    def super_worker(sample_id, sample_record, tasks_to_perform):
        success = True

        if constants.TASK_DOWNLOAD in tasks_to_perform:
            success = True

        if success is True and constants.TASK_DECOMPILE in tasks_to_perform:
            apk_path = sample_record['metadata']['apk_path']
            dx_path = sample_record['metadata']['dx_path']
            success = decompile_worker(apk_path, dx_path)

        if success is True and constants.TASK_THIRD_PARTY_LIBS in tasks_to_perform:
            success = True

        if success is True and constants.TASK_EVALUATE in tasks_to_perform:
            success = True

        return success, sample_id, sample_record

    def super_worker_callback(self, result):
        success = result[0]
        sample_id = result[1]
        sample_record = result[2]

        if success is True:
            self.dset.update_record(sample_id, sample_record)

            if self.delete_apks is True:
                self.dset.delete_apk(sample_id)

            if self.delete_dxs is True:
                self.dset.delete_dx(sample_id)
        else:
            self.failed_samples.append(sample_id)
            self.dset.delete_record(sample_id)

        self.processed_samples += 1

        if self.cfg.is_being_logged is True and (datetime.now() - self.last_update_time) > timedelta(
                seconds=20):
            self.update_neptune_progress()
            self.last_update_time = datetime.now()

        self.pbar.update()

    def update_neptune_progress(self):
        if self.cfg.is_being_logged is True:
            curr_time = datetime.now()
            fraction = self.processed_samples / self.dset.n_samples
            self.experiment.log_metric(self.progress_metric_name, (curr_time - self.start_time).total_seconds(), y=fraction)

    def eval_neptune(self):
        if self.cfg.is_being_logged:
            neptune.send_artifact(self.cfg.config_path)
            neptune.stop()
