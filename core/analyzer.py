import pandas as pd
import numpy as np
import os
from tqdm import tqdm
import core.helpers as helpers
import base64
import pyjadx

class Task:
    pass


class ComputeStringStatistics(Task):
    def __init__(self, jadx, apks_to_search, output_path, strings_to_search=None, count_imports=True):
        self.jadx = jadx
        self.strings_to_search = strings_to_search
        self.apks_to_search = apks_to_search
        self.count_imports = count_imports

        self.csv_filename = helpers.establish_results_filepath(output_path, 'results', 'csv')
        self.failed_files_filename = helpers.establish_results_filepath(output_path, 'failed_files', 'txt')

        self.occurrences_counter = pd.DataFrame(0, index=np.arange(len(self.apks_to_search)), columns=self.strings_to_search)
        self.occurrences_counter['file'] = [os.path.basename(x) for x in self.apks_to_search]
        cols = self.occurrences_counter.columns.tolist()
        cols = cols[-1:] + cols[:-1]
        self.occurrences_counter = self.occurrences_counter[cols]

    def run(self):
        correctly_processed = []

        with open(self.failed_files_filename, 'w') as f:
            for i, apk in tqdm(enumerate(self.apks_to_search)):
                if not self.count_occurrences_in_code(apk, i):
                    f.write(f'{apk}\n')
                    print(os.path.basename(apk))
                    self.occurrences_counter = self.occurrences_counter[self.occurrences_counter.file != os.path.basename(apk)]
                else:
                    correctly_processed.append(apk)

        family_names = [helpers.get_apk_label(path) for path in correctly_processed]
        sum_row = {self.occurrences_counter.columns.tolist()[0]: len(self.apks_to_search)}

        for col in self.occurrences_counter.columns.tolist()[1:]:
            sum_row[col] = self.occurrences_counter[col].sum()
        sum_row['family_name'] = 0
        sum_df = pd.DataFrame(sum_row, index=["sum"])

        # add the family name column
        self.occurrences_counter['family_name'] = family_names

        self.occurrences_counter = self.occurrences_counter.append(sum_df)
        self.occurrences_counter.to_csv(self.csv_filename, index=False, sep=';')

    def count_occurrences_in_code(self, apk, i):
        try:
            decompiler = self.jadx.load(apk)
        except:
            return False

        for cls in decompiler.classes:
            if cls.fullname.split('.')[0] == 'android':
                continue
            for line in cls.code.split('\n'):
                for s in self.strings_to_search:
                    if s not in line:
                        continue
                    if not self.count_imports and line.split(' ') and line.split(' ')[0] == 'import':
                        continue
                    self.occurrences_counter.at[i, s] += 1
        return True


class DeobfuscateBase64(Task):
    def __init__(self, jadx, apks_to_search, output_path):
        self.jadx = jadx
        self.apks_to_search = apks_to_search
        self.output_path = output_path

    def run(self):
        with open(self.output_path, 'w') as handle:
            counter = 0
            n_total_strings = 0
            for apk in tqdm(self.apks_to_search):
                base64_strings = self.decode_base64_apk(apk)
                if len(base64_strings) > 0:
                    counter += 1
                    n_total_strings += len(base64_strings)

                    handle.write(f'{os.path.basename(apk)}\n')
                    for s in base64_strings:
                        handle.write(f'\t {s}\n')
            handle.write(f'In total, {n_total_strings} Base64 strings were found in: {counter} files.')

    def decode_base64_apk(self, apk):
        strings = []
        decompiler = self.jadx.load(apk)
        for cls in decompiler.classes:
            if cls.fullname.split('.')[0] == 'android':
                continue
            for line in cls.code.split('\n'):
                if 'Base64' in line:
                    res = self.decode_base64_line_of_code(line)
                    if res is not None:
                        strings.append(res)
        return strings

    @staticmethod
    def decode_base64_line_of_code(line_of_code):
        splt = line_of_code.split('Base64.decode("')
        if len(splt) > 1:
            return base64.decodebytes(str.encode(splt[1].split('\"')[0]))
        else:
            return None
