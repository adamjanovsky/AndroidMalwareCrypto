import pandas as pd
import numpy as np
import os
from tqdm import tqdm
import core.helpers as helpers
import base64


class Task:
    pass


class ComputeStringStatistics(Task):
    def __init__(self, jadx, apks_to_search, output_path, strings_to_search=None, count_imports=True):
        self.jadx = jadx
        self.strings_to_search = strings_to_search
        self.apks_to_search = apks_to_search
        self.count_imports = count_imports

        self.csv_filename = helpers.establish_results_filepath(output_path, 'results', 'csv')
        self.failed_files_filename = helpers.establish_results_filepath(output_path, 'failed_files', 'txt')

        self.occurrences_counter = pd.DataFrame(0, index=np.arange(len(self.apks_to_search)), columns=self.strings_to_search)
        self.occurrences_counter['file'] = [os.path.basename(x) for x in self.apks_to_search]
        cols = self.occurrences_counter.columns.tolist()
        cols = cols[-1:] + cols[:-1]
        self.occurrences_counter = self.occurrences_counter[cols]

    def run(self):
        family_names = [helpers.get_apk_label(path) for path in self.apks_to_search]

        with open(self.failed_files_filename, 'w') as f:
            for i, apk in tqdm(enumerate(self.apks_to_search)):
                if not self.count_occurrences_in_code(apk, i):
                    f.write(f'{apk}\n')


        sum_row = {self.occurrences_counter.columns.tolist()[0]: len(self.apks_to_search)}

        for col in self.occurrences_counter.columns.tolist()[1:]:
            sum_row[col] = self.occurrences_counter[col].sum()
        sum_row['family_name'] = 0
        sum_df = pd.DataFrame(sum_row, index=["sum"])

        # add the family name column
        self.occurrences_counter['family_name'] = family_names

        self.occurrences_counter = self.occurrences_counter.append(sum_df)
        self.occurrences_counter.to_csv(self.csv_filename, index=False, sep=';')

    def count_occurrences_in_code(self, apk, i):
        try:
            decompiler = self.jadx.load(apk)
        except:
            return False

        for cls in decompiler.classes:
            if cls.fullname.split('.')[0] == 'android':
                continue
            for line in cls.code.split('\n'):
                for s in self.strings_to_search:
                    if s not in line:
                        continue
                    if not self.count_imports and line.split(' ') and line.split(' ')[0] == 'import':
                        continue
                    self.occurrences_counter.at[i, s] += 1\
        return True


class DeobfuscateBase64(Task):
    def __init__(self, jadx, apks_to_search, output_path):
        self.jadx = jadx
        self.apks_to_search = apks_to_search
        self.output_path = output_path
        self.result_filename = helpers.establish_results_filepath(self.output_path, 'base64_strings', 'txt')

    def run(self):
        """
        with open(self.result_filename, 'w') as handle:
            for i, apk in tqdm(enumerate(self.apks_to_search)):
                str_to_write = self.decode_base64_apk(apk)
                handle.write(f'{i}: {apk}\n')
                for s in str_to_write:
                    handle.write(f'\t {s}\n')
        """
        pass

    def decode_base64_apk(self, apk):
        strings = []
        decompiler = self.jadx.load(apk)
        for cls in decompiler.classes:
            if cls.fullname.split('.')[0] == 'android':
                continue
            for line in cls.code.split('\n'):
                if 'Base64' in line:
                    strings.append(self.decode_base64_line_of_code(line))
        return strings

    @staticmethod
    def decode_base64_line_of_code(line_of_code):
        splt = line_of_code.split('Base64.decode(')

        if len(splt) > 1:
            print(line_of_code.split('\"'))
            return ''
        else:
            return ''
